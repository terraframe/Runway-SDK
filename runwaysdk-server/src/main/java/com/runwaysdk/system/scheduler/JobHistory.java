/**
 * Copyright (c) 2015 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
package com.runwaysdk.system.scheduler;

import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.Locale;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.runwaysdk.RunwayException;
import com.runwaysdk.business.BusinessFacade;
import com.runwaysdk.business.SmartException;
import com.runwaysdk.constants.BusinessInfo;
import com.runwaysdk.dataaccess.MdAttributeDAOIF;
import com.runwaysdk.dataaccess.ProgrammingErrorException;
import com.runwaysdk.dataaccess.transaction.Transaction;
import com.runwaysdk.generation.loader.LoaderDecorator;
import com.runwaysdk.query.OIterator;
import com.runwaysdk.query.QueryFactory;

public class JobHistory extends JobHistoryBase
{
  private static final long serialVersionUID = -1321109726;
  
  private static final Logger logger = LoggerFactory.getLogger(JobHistory.class);
  
  public JobHistory()
  {
    super();
  }
  
  /**
   * @MdMethod
   * 
   * Used to clear all NON RUNNING job history.
   */
  @Transaction
  public static void clearHistory()
  {
    JobHistoryQuery query = new JobHistoryQuery(new QueryFactory());
    query.WHERE(query.getStatus().notContainsAny(AllJobStatus.RUNNING, AllJobStatus.QUEUED));
    OIterator<? extends JobHistory> jhs = query.getIterator();
    
    while (jhs.hasNext())
    {
      JobHistory jh = jhs.next();
      jh.delete();
    }
  }
  
  /**
   * Serializes the given exception and sets the 'errorJson' attribute on this history object.
   */
  public void setError(Throwable t)
  {
    this.setErrorJson(JobHistory.exceptionToJson(t).toString());
  }
  
  /**
   * Returns the localized exception which has occurred during execution of the ExecutableJob which this history represents (if one exists).
   * If one does not exist, null will be returned.
   */
  public String getLocalizedError(Locale locale)
  {
    if (this.getErrorJson() == null || this.getErrorJson().length() == 0)
    {
      return null;
    }
    else
    {
      try
      {
        return JobHistory.readLocalizedException(new JSONObject(this.getErrorJson()), locale);
      }
      catch (JSONException e)
      {
        logger.error("Error constructing localized message from error json", e);
        throw new ProgrammingErrorException(e);
      }
    }
  }
  
  /**
   * Returns a localized exception message from json which was generated by the "exceptionToJson" method of this class,
   * typically found on the JobHistory's "errorJson" attribute.
   */
  public static String readLocalizedException(JSONObject json, Locale locale)
  {
    try
    {
      try
      {
        if (json.has("type"))
        {
          String type = json.getString("type");
          
          Class<?> c = LoaderDecorator.loadClass(type);
          
          Throwable t = (Throwable) c.newInstance();
          
          if (t instanceof SmartException)
          {
            SmartException se = (SmartException) t;
            
            BusinessFacade.setSmartExceptionLocale(se, locale);
            
            if (json.has("attributes"))
            {
              JSONArray attrs = json.getJSONArray("attributes");
              
              for (int i = 0; i < attrs.length(); ++i)
              {
                JSONObject attr = attrs.getJSONObject(i);
                
                if (!attr.getString("key").equals(BusinessInfo.OID))
                {
                  se.setValue(attr.getString("key"), attr.getString("value"));
                }
              }
            }
            
            return se.localize(locale);
          }
          else if (t instanceof RunwayException)
          {
            
          }
        }
      }
      catch (ClassNotFoundException | InstantiationException | IllegalAccessException e)
      {
        logger.error("Could not get error from type.", e);
      }
      
      if (json.has("message"))
        return json.getString("message");
      
      logger.error("Unable to convert json into suitable error message");
      return new ProgrammingErrorException("").getLocalizedMessage();
    }
    catch (JSONException e)
    {
      logger.error("Error constructing localized message from error json", e);
      throw new ProgrammingErrorException(e);
    }
  }
  
  /**
   * Serializes an exception to json, ready to be stored on the JobHistory's "errorJson" attribute.
   */
  public static JSONObject exceptionToJson(Throwable t)
  {
    try
    {
      JSONObject json = new JSONObject();
      
      if (t instanceof InvocationTargetException)
      {
        t = t.getCause();
      }
      
      if (t instanceof SmartException)
      {
        SmartException se = ( (SmartException) t );
        
        json.put("type", se.getType());
        
        JSONArray attrs = new JSONArray();
        
        List<? extends MdAttributeDAOIF> mdAttrs = se.getMdAttributeDAOs();
        for (MdAttributeDAOIF mdAttr : mdAttrs)
        {
          JSONObject attr = new JSONObject();
          
          attr.put("key", mdAttr.definesAttribute());
          attr.put("value", se.getValue(mdAttr.definesAttribute()));
          
          attrs.put(attr);
        }
        
        json.put("attributes", attrs);
      }
      else
      {
        json.put("type", t.getClass().getName());
      }
      
      // This here is needed for exceptions that aren't RunwayException or SmartException.
      String message = ExecutableJob.getMessageFromException(t);
      json.put("message", message);
      
      return json;
    }
    catch (Throwable t2)
    {
      logger.error("Critical failure when writing error of job history, two errors now exist. Scheduled job error: ", t);
      logger.error("Critical failure when writing error of job history, two errors now exist. Error preventing history writing: ", t2);
      try
      {
        return new JSONObject("{type:'java.lang.RuntimeException', message:'Critical failure writing job history. Contact your system administrator.'}");
      }
      catch (JSONException e)
      {
        throw new RuntimeException(e);
      }
    }
  }
}