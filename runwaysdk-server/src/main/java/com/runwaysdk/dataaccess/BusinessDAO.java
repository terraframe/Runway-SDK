/**
 * Copyright (c) 2015 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Created on August 13, 2004
 */
package com.runwaysdk.dataaccess;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.runwaysdk.business.Business;
import com.runwaysdk.business.BusinessFacade;
import com.runwaysdk.business.Relationship;
import com.runwaysdk.business.generation.GenerationUtil;
import com.runwaysdk.constants.MdRelationshipInfo;
import com.runwaysdk.dataaccess.attributes.AttributeValueException;
import com.runwaysdk.dataaccess.attributes.entity.Attribute;
import com.runwaysdk.dataaccess.cache.DataNotFoundException;
import com.runwaysdk.dataaccess.cache.ObjectCache;
import com.runwaysdk.dataaccess.database.BusinessDAOFactory;
import com.runwaysdk.dataaccess.database.RelationshipDAOFactory;
import com.runwaysdk.dataaccess.metadata.MdBusinessDAO;
import com.runwaysdk.dataaccess.metadata.MdRelationshipDAO;
import com.runwaysdk.query.BusinessDAOQuery;
import com.runwaysdk.query.Condition;
import com.runwaysdk.query.OIterator;
import com.runwaysdk.query.OR;
import com.runwaysdk.query.QueryFactory;

/**
 * A BusinessDAO has a collection of attributes. Each attribute is a name-value
 * pair. The BusinessDAO class is the main abstraction of the dataaccess layer.
 * BusinessDAOs can participate in relationships with other BusinessDAOs. A
 * BusinessDAO's class determines the number and kinds of attributes for this
 * BusinessDAO.
 * 
 * @author nathan
 * @version $Revision: 1.26 $
 * @since 1.4
 */
public class BusinessDAO extends ElementDAO implements BusinessDAOIF
{
  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = 2824646979293186580L;

  /**
   * The default constructor, does not set any attributes
   */
  public BusinessDAO()
  {
    super();
  }

  /**
   * Constructs a BusinessDAO from the given hashtable of Attributes.
   * 
   * <br/>
   * <b>Precondition:</b> attributeMap != null <br/>
   * <b>Precondition:</b> classType != null
   * 
   * @param attributeMap
   * @param classType
   */
  public BusinessDAO(Map<String, Attribute> attributeMap, String classType)
  {
    super(attributeMap, classType);
  }

  /**
   * Creates an empty BusinessDAO. For subclasses creates a subtype based on the
   * classType, and fills the attributes with the attribute map
   * 
   * @param attributeMap
   *          The attribute mappings of the class
   * @return The new class created
   */
  public BusinessDAO create(Map<String, Attribute> attributeMap, String classType)
  {
    return new BusinessDAO(attributeMap, classType);
  }

  /**
   * Returns a deep cloned-copy of this BusinessDAO
   */
  public BusinessDAO getBusinessDAO()
  {
    // Only clone the object if this object comes from a cache.
    if (this.isFromCache())
    {
      return this.clone();
    }
    else
    {
      return this;
    }
  }

  /**
   * Returns an array of Relationship objects that represent child relationships
   * with this BusinessDAO of the given relationship type.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type:
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO for the given relationship type
   * 
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return Array of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getChildren(String relationshipType)
  {
    return ObjectCache.getChildren(this.getOid(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent child relationships between the this object and the given
   * child object.
   * 
   * <br/>
   * <b>Precondition:</b> childObject != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO with the given child for the given
   * relationship type
   * 
   * @param childObject
   *          object that is a child of this object.
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects
   */
  public List<RelationshipDAOIF> getChildren(BusinessDAOIF childObject, String relationshipType)
  {
    return this.getChildren(childObject.getOid(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent child relationships between the this object and the child
   * object with the given oid.
   * 
   * <br/>
   * <b>Precondition:</b> childOid != null <br/>
   * <b>Precondition:</b> !childOid.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipTypeis a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO with the given child for the given
   * relationship type
   * 
   * @param childOid
   *          oid to the child of this object.
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects.
   */
  public List<RelationshipDAOIF> getChildren(String childOid, String relationshipType)
  {
    return RelationshipDAOFactory.get(this.getOid(), childOid, relationshipType);
  }

  /**
   * Returns a LinkedList of Relationship objects that represent child
   * relationships with this BusinessDAO for relationships if all names.
   * 
   * <br/>
   * <b>Precondition:</b> true
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO
   * 
   * @return LinkedList of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getAllChildren()
  {
    List<RelationshipDAOIF> relationshipList = new LinkedList<RelationshipDAOIF>();

    List<MdRelationshipDAOIF> mdRelationshipList = this.getMdBusinessDAO().getAllParentMdRelationships();

    for (MdRelationshipDAOIF mdRelationshipIF : mdRelationshipList)
    {
      if (mdRelationshipIF.isAbstract())
      {
        continue;
      }

      relationshipList.addAll(ObjectCache.getChildren(this.getOid(), mdRelationshipIF.definesType()));
    }
    return relationshipList;
  }

  /**
   * Returns an array of Relationship objects that represent parent
   * relationships with this BusinessDAO of the given relationship type.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO for the given relationship type
   * 
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return array of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getParents(String relationshipType)
  {
    return ObjectCache.getParents(this.getOid(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent parent relationships between the this object and the given
   * parent object.
   * 
   * <br/>
   * <b>Precondition:</b> parentObject != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO with the given parent for the given
   * relationship type
   * 
   * @param parentObject
   *          object that is a parent of this object.
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects
   */
  public List<RelationshipDAOIF> getParents(BusinessDAOIF parentObject, String relationshipType)
  {
    return this.getParents(parentObject.getOid(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent parent relationships between the this object and the parent
   * object with the given oid.
   * 
   * <br/>
   * <b>Precondition:</b> parentOid != null <br/>
   * <b>Precondition:</b> !parentOid.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.)
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO with the given parent for the given
   * relationship type
   * 
   * @param parentOid
   *          oid to a parent of this object.
   * @param relationshipType
   *          relationshipType specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects
   */
  public List<RelationshipDAOIF> getParents(String parentOid, String relationshipType)
  {
    return RelationshipDAOFactory.get(parentOid, this.getOid(), relationshipType);
  }

  /**
   * Returns a LinkedList of Relationship objects that represent parent
   * relationships with this BusinessDAO for relationships of all names.
   * 
   * <br/>
   * <b>Precondition:</b> true
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO
   * 
   * @return LinkedList of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getAllParents()
  {
    List<RelationshipDAOIF> relationshipList = new LinkedList<RelationshipDAOIF>();

    List<MdRelationshipDAOIF> mdRelationshipList = this.getMdBusinessDAO().getAllChildMdRelationships();

    for (MdRelationshipDAOIF mdRelationshipIF : mdRelationshipList)
    {
      if (mdRelationshipIF.isAbstract())
      {
        continue;
      }

      relationshipList.addAll(ObjectCache.getParents(this.getOid(), mdRelationshipIF.definesType()));
    }
    return relationshipList;
  }

  /**
   * Add the given BusinessDAO as a child to this BusinessDAO for the given
   * relationship.
   * 
   * <br/>
   * <b>Precondition:</b> childBusinessDAO != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> adds the BusinessDAO as a child of this BusinessDAO
   * for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param childBusinessDAO
   *          BusinessDAO to be added as a child to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addChild(BusinessDAOIF childBusinessDAO, String relationshipType)
  {
    return addChild(childBusinessDAO.getOid(), relationshipType);
  }

  /**
   * Add the BusinessDAO with the given oid as a child to this BusinessDAO for
   * the given relationship.
   * 
   * <br/>
   * <b>Precondition:</b> childOid != null <br/>
   * <b>Precondition:</b> !childOid.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> adds the BusinessDAO with the given oid as a child of
   * this BusinessDAO for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param childOid
   *          oid of the BusinessDAO to be added as a child to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addChild(String childOid, String relationshipType)
  {
    RelationshipDAO newChildRelationship = RelationshipDAO.newInstance(this.getOid(), childOid, relationshipType);
    return newChildRelationship;
  }

  /**
   * Removes the given BusinessDAO from the children of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childBusinessDAO != null <br/>
   * <b>Precondition:</b> childBusinessDAO is already a child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * @param childBusinessDAO
   *          BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllChildren(BusinessDAOIF childBusinessDAO, String relationshipType)
  {
    this.removeAllChildren(childBusinessDAO, relationshipType, false);
  }

  /**
   * Removes the given BusinessDAO from the children of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childBusinessDAO != null <br/>
   * <b>Precondition:</b> childBusinessDAO is already a child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * @param childBusinessDAO
   *          BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllChildren(BusinessDAOIF childBusinessDAO, String relationshipType, boolean businessContext)
  {
    this.removeAllChildren(childBusinessDAO.getOid(), relationshipType, businessContext);
  }

  /**
   * Removes the given BusinessDAO with the given oid from the children of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childOid != null <br/>
   * <b>Precondition:</b> childOid is a oid to a businessDAO that is already a
   * child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param childOid
   *          Id of a BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllChildren(String childOid, String relationshipType)
  {
    this.removeAllChildren(childOid, relationshipType, false);
  }

  /**
   * Removes the given BusinessDAO with the given oid from the children of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childOid != null <br/>
   * <b>Precondition:</b> childOid is a oid to a businessDAO that is already a
   * child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param childOid
   *          Id of a BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllChildren(String childOid, String relationshipType, boolean businessContext)
  {
    List<RelationshipDAOIF> relationshipDAOlist = RelationshipDAO.get(this.getOid(), childOid, relationshipType);

    if (relationshipDAOlist.size() == 0)
    {
      String error = "Object does not have child object with oid [" + childOid + "], in the [" + relationshipType + "] relationship.";
      throw new DataNotFoundException(error, MdRelationshipDAO.getMdRelationshipDAO(relationshipType));
    }

    for (RelationshipDAOIF relationshipIF : relationshipDAOlist)
    {
      if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(relationshipIF.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(relationshipIF);
        relationship.delete();
      }
      else
      {
        relationshipIF.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br/>
   * <b>Precondition:</b> oid to relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationshipId
   *          oid to a child relationship.
   */
  public void removeChild(String relationshipId)
  {
    this.removeChild(relationshipId, false);
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br/>
   * <b>Precondition:</b> oid to relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationshipId
   *          oid to a child relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeChild(String relationshipId, boolean businessContext)
  {
    RelationshipDAOIF relationshipDAOIF = RelationshipDAO.get(relationshipId);
    this.removeChild(relationshipDAOIF, businessContext);
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipIF != null <br/>
   * <b>Precondition:</b> Relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationship
   *          child relationship.
   */
  public void removeChild(RelationshipDAOIF relationshipIF)
  {
    this.removeChild(relationshipIF, false);
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipIF != null <br/>
   * <b>Precondition:</b> Relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationship
   *          child relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeChild(RelationshipDAOIF relationshipIF, boolean businessContext)
  {
    if (!relationshipIF.getParentOid().equals(this.getOid()))
    {
      String msg = "Relationship with oid [" + relationshipIF.getOid() + "] " + "does not represent a child relationship with the object with oid [" + getOid() + "]";
      throw new DataNotFoundException(msg, MdRelationshipDAO.getMdRelationshipDAO(relationshipIF.getType()));
    }

    if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(relationshipIF.getMdRelationshipDAO()))
    {
      Relationship relationship = BusinessFacade.get(relationshipIF);
      relationship.delete();
    }
    else
    {
      // Delete the relationship
      relationshipIF.getRelationshipDAO().delete();
    }
  }

  /**
   * Add the given BusinessDAO as a parent to this BusinessDAO for the given
   * relationship.
   * 
   * <br/>
   * <b>Precondition:</b> parentBusinessDAO != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type. <br/>
   * <b>Postcondition:</b> adds the BusinessDAO as a parent of this BusinessDAO
   * for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param parentBusinessDAO
   *          BusinessDAO to be added as a parent to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addParent(BusinessDAOIF parentBusinessDAO, String relationshipType)
  {
    return addParent(parentBusinessDAO.getOid(), relationshipType);
  }

  /**
   * Add the BusinessDAO with the given oid as a parent to this BusinessDAO for
   * the given relationship.
   * 
   * <br/>
   * <b>Precondition:</b> parentOid != null && !parentOid("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * <br/>
   * <b>Postcondition:</b> adds the BusinessDAO with the given oid as a parent of
   * this BusinessDAO for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param parentOid
   *          oid of BusinessDAO to be added as a child to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addParent(String parentOid, String relationshipType)
  {
    RelationshipDAO newParentRelationshipDAO = RelationshipDAO.newInstance(parentOid, this.getOid(), relationshipType);

    return newParentRelationshipDAO;
  }

  /**
   * Removes the given BusinessDAO from the parents of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentBusinessDAO != null <br/>
   * <b>Precondition:</b> parentBusinessDAO is already a parent of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentBusinessDAO
   *          BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllParents(BusinessDAOIF parentBusinessDAO, String relationshipType)
  {
    this.removeAllParents(parentBusinessDAO, relationshipType, false);
  }

  /**
   * Removes the given BusinessDAO from the parents of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentBusinessDAO != null <br/>
   * <b>Precondition:</b> parentBusinessDAO is already a parent of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentBusinessDAO
   *          BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllParents(BusinessDAOIF parentBusinessDAO, String relationshipType, boolean businessContext)
  {
    this.removeAllParents(parentBusinessDAO.getOid(), relationshipType, businessContext);
  }

  /**
   * Removes the BusinessDAO with the given oid from the parents of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentOid != null <br/>
   * <b>Precondition:</b> parentOid a oid to an object that is already a parent of
   * this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentOid
   *          oid to the BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllParents(String parentOid, String relationshipType)
  {
    this.removeAllParents(parentOid, relationshipType, false);
  }

  /**
   * Removes the BusinessDAO with the given oid from the parents of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentOid != null <br/>
   * <b>Precondition:</b> parentOid a oid to an object that is already a parent of
   * this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentOid
   *          oid to the BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllParents(String parentOid, String relationshipType, boolean businessContext)
  {
    List<RelationshipDAOIF> relationshipDAOlist = RelationshipDAO.get(parentOid, this.getOid(), relationshipType);

    if (relationshipDAOlist.size() == 0)
    {
      String error = "Object does not have parent object with oid [" + parentOid + "] in the [" + relationshipType + "] relationship.";
      throw new DataNotFoundException(error, MdRelationshipDAO.getMdRelationshipDAO(relationshipType));
    }

    // delete all of the relatinoships
    for (RelationshipDAOIF relationshipIF : relationshipDAOlist)
    {
      if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(relationshipIF.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(relationshipIF);
        relationship.delete();
      }
      else
      {
        relationshipIF.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br>
   * <b>Precondition:</b> oid to relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationshipId
   *          oid to a parent relationship.
   */
  public void removeParent(String relationshipId)
  {
    this.removeParent(relationshipId, false);
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br>
   * <b>Precondition:</b> oid to relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationshipId
   *          oid to a parent relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeParent(String relationshipId, boolean businessContext)
  {
    RelationshipDAOIF relationshipDAOIF = RelationshipDAO.get(relationshipId);
    this.removeParent(relationshipDAOIF, businessContext);
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br>
   * <b>Precondition:</b> relationshipIF != null <br>
   * <b>Precondition:</b> Relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationship
   *          parent relationship.
   */
  public void removeParent(RelationshipDAOIF relationshipIF)
  {
    this.removeParent(relationshipIF, false);
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br>
   * <b>Precondition:</b> relationshipIF != null <br>
   * <b>Precondition:</b> Relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationship
   *          parent relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeParent(RelationshipDAOIF relationshipIF, boolean businessContext)
  {
    if (!relationshipIF.getChildOid().equals(this.getOid()))
    {
      String error = "Relationship with oid [" + relationshipIF.getOid() + "] " + "does not represent a parent relationship with the object with oid [" + getOid() + "]";
      throw new DataNotFoundException(error, MdRelationshipDAO.getMdRelationshipDAO(relationshipIF.getType()));
    }

    // Delete the relationship
    if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(relationshipIF.getMdRelationshipDAO()))
    {
      Relationship relationship = BusinessFacade.get(relationshipIF);
      relationship.delete();
    }
    else
    {
      relationshipIF.getRelationshipDAO().delete();
    }
  }

  /**
   *
   */
  public String save(boolean validateRequired)
  {
    return super.save(validateRequired);
  }

  /**
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   * 
   */
  public void delete(boolean businessContext)
  {
    MdBusinessDAOIF mdBusiness = this.getMdBusinessDAO();

    OIterator<BusinessDAOIF> mdAttrRefIerator = MdBusinessDAO.getAllReferenceAttributes(mdBusiness);
    while (mdAttrRefIerator.hasNext())
    {
      MdAttributeReferenceDAOIF mdAttributeReferenceIF = (MdAttributeReferenceDAOIF) mdAttrRefIerator.next();

      try
      {
        // get the defining parent class
        MdClassDAOIF loopMdEntity = (MdClassDAOIF) mdAttributeReferenceIF.definedByClass();

        if (loopMdEntity instanceof MdEntityDAOIF)
        {
          clearAttributeValues((MdEntityDAOIF) loopMdEntity, mdAttributeReferenceIF, this.getOid());
        }
      }
      catch (AttributeValueException e)
      {
        MdEntityDAOIF refMdEntityIF = (MdEntityDAOIF) mdAttributeReferenceIF.definedByClass();
        String error = "Cannot delete object [" + this.getKey() + "] - " + "Attribute [" + mdAttributeReferenceIF.definesAttribute() + "] on type [" + refMdEntityIF.definesType() + "] references it and is a required attribute.";
        throw new CannotDeleteReferencedObject(error, this, refMdEntityIF, mdAttributeReferenceIF);
      }
    }

    mdAttrRefIerator.close();

    QueryFactory queryFactory = new QueryFactory();
    // Perform a cascade delete of any child object if this object participates
    // in a composition relationship
    BusinessDAOQuery mdRelationshipQuery = queryFactory.businessDAOQuery(MdRelationshipInfo.CLASS);

    // cycle through all parent classes of this instance and build the query.
    // OR together MdRelationships where the parent class equals a MdBusiness
    // that is in this object's type
    // hierarchy
    List<MdBusinessDAOIF> inheritsFrom = mdBusiness.getSuperClasses();

    Condition[] conditions = new Condition[inheritsFrom.size()];

    for (int i = 0; i < inheritsFrom.size(); i++)
    {
      MdBusinessDAOIF parentMdBusiness = inheritsFrom.get(i);

      conditions[i] = mdRelationshipQuery.aReference(MdRelationshipInfo.PARENT_MD_BUSINESS).EQ(parentMdBusiness.getOid());
    }

    mdRelationshipQuery.WHERE(mdRelationshipQuery.aBoolean(MdRelationshipInfo.COMPOSITION).EQ(true).AND(OR.get(conditions)));

    // get the list of all the MdRelationship objects returned
    OIterator<BusinessDAOIF> businessDAOIterator = mdRelationshipQuery.getIterator();
    while (businessDAOIterator.hasNext())
    {
      // get the name of the relationship
      MdRelationshipDAO relationship = (MdRelationshipDAO) businessDAOIterator.next();
      if (relationship.isAbstract())
      {
        continue;
      }

      List<RelationshipDAOIF> children = this.getChildren(relationship.definesType());

      // now delete each child
      for (RelationshipDAOIF rel : children)
      {
        // get each child, then delete it
        BusinessDAOIF child = rel.getChild();

        // Only perform the delete if the object is mastered at this site, or
        // the
        // delete occurs as a result of an import.
        if (EntityDAO.isMasteredHere(child) || this.isImport())
        {
          if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(child.getMdBusinessDAO()))
          {
            Business business = BusinessFacade.get(child);
            business.delete();
          }
          else
          {
            BusinessDAO childObject = child.getBusinessDAO();
            childObject.delete();
          }
        }
      }
    }

    // Remove all relationships to this object
    this.deleteFromAllParentRelations(businessContext);
    this.deleteAllChildRelations(businessContext);

    super.delete(businessContext);
  }

  /**
   * Deletes all parent relationships.
   * 
   * <br/>
   * <b>Postcondition:</b> parent relationships are removed
   * (RelationshipFactory.getParents(businessDAO.getOid(), "")).length == 0
   * 
   */
  private void deleteFromAllParentRelations(boolean businessContext)
  {
    for (RelationshipDAOIF parent : this.getAllParents())
    {
      if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(parent.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(parent);
        relationship.delete();
      }
      else
      {
        parent.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Deletes all children relationships.
   * 
   * <br/>
   * <b>Postcondition:</b> parent relationships are removed
   * (RelationshipFactory.getChildren(businessDAO.getOid(), "")).length == 0
   * 
   */
  private void deleteAllChildRelations(boolean businessContext)
  {
    for (RelationshipDAOIF child : this.getAllChildren())
    {
      if (businessContext && !GenerationUtil.isSkipCompileAndCodeGeneration(child.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(child);
        relationship.delete();
      }
      else
      {
        child.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Returns a MdBusiness that defines this object's classs.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> true
   * 
   * @return a MdBusiness that defines this object's classs.
   */
  public MdBusinessDAOIF getMdBusinessDAO()
  {
    return MdBusinessDAO.getMdBusinessDAO(this.getType());
  }

  /**
   * Returns a clone of the given BusinessDAO instance. The cloned instance can
   * be applied to the database.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> Clone (deep copy) of this BusinessDAO instance is
   * returned.
   * 
   * @return a clone of the given BusinessDAO instance
   */
  public BusinessDAO clone()
  {
    HashMap<String, Attribute> newAttrList = new HashMap<String, Attribute>();

    // clone all of the attributes
//    for (Attribute attrOld : this.getObjectState().getAttributeMap().values())
    // We are bypassing the abstraction and not calling this.getObjectState().getAttributeMap() to prevent a 
    // stack overflow in the case where the {@link DAOStatePostTransaction} is updating the properties of a 
    // reference after a transaction
    for (Attribute attrOld : this.getObjectState().attributeMap.values())
    {
      Attribute attrNew = attrOld.attributeClone();
      newAttrList.put(attrNew.getName(), attrNew);
    }
    BusinessDAO clonedObject = (BusinessDAO) BusinessDAOFactory.factoryMethod(newAttrList, new String(this.componentType), true);

    clonedObject.setIsNew(this.isNew());
    clonedObject.setAppliedToDB(this.isAppliedToDB());
    return clonedObject;
  }

  /**
   * Returns a copy of the given BusinessDAO instance, with a new oid and
   * mastered at the current site. The state of the object is new and has not
   * been applied to the database.
   * 
   * @return a copy of the given BusinessDAO instance
   */
  public BusinessDAO copy()
  {
    HashMap<String, Attribute> newAttrMap = new HashMap<String, Attribute>();

    BusinessDAO copiedObject = BusinessDAO.newInstance(this.getType());

    // clone all of the attributes
    for (Attribute attrOld : this.getObjectState().getAttributeMap().values())
    {
      if (! ( attrOld ).getMdAttribute().isSystem())
      {
        Attribute attrNew = attrOld.attributeCopy();
        attrNew.setContainingComponent(copiedObject);
        newAttrMap.put(attrNew.getName(), attrNew);
      }
    }

    // This should overwrite the non-system attributes, such as oid and site
    // master
    copiedObject.getObjectState().getAttributeMap().putAll(newAttrMap);

    return copiedObject;
  }

  /**
   * Tests if <em>this</em> BusinessDAO is a child of another BusinessDAO.
   * 
   * @param possibleParent
   *          the parent BusinessDAO to test with.
   * @param relationshipType
   *          the type of the relationship.
   * @return true if the relationship is valid, false otherwise.
   */
  public boolean isChildOf(BusinessDAO possibleParent, String relationshipType)
  {
    List<RelationshipDAOIF> relList = this.getParents(relationshipType);
    for (RelationshipDAOIF rel : relList)
    {
      BusinessDAOIF parent = rel.getParent();
      BusinessDAO businessDAOParent = parent.getBusinessDAO();

      if (businessDAOParent.getOid().compareTo(possibleParent.getOid()) == 0)
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Tests if <em>this</em> BusinessDAO is a parent of another BusinessDAO.
   * 
   * @param possibleChild
   *          the child BusinessDAO to test with.
   * @param relationshipType
   *          type of the relationship.
   * @return true if the relationship is valid, false otherwise.
   */
  public boolean isParentOf(BusinessDAO possibleChild, String relationshipType)
  {
    List<RelationshipDAOIF> relList = this.getChildren(relationshipType);
    for (RelationshipDAOIF rel : relList)
    {
      BusinessDAOIF child = rel.getChild();
      BusinessDAO businessDAOChild = child.getBusinessDAO();
      if (businessDAOChild.getOid().compareTo(possibleChild.getOid()) == 0)
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Returns a BusinessDAO of the given oid in the database.
   * 
   * <br/>
   * <b>Precondition:</b> oid != null <br/>
   * <b>Precondition:</b> !oid.trim().equals("") <br/>
   * <b>Postcondition:</b> return value may not be null <br/>
   * <b>Postcondition:</b> BusinessDAO representing the item in the database of
   * the given oid is returned
   * 
   * @param oid
   *          element oid of an item in the database
   * @return BusinessDAO instance of the given oid
   */
  public static BusinessDAOIF get(String oid)
  {
    return ObjectCache.getBusinessDAO(oid);
  }

  /**
   * Returns a BusinessDAO of the given type with the given key in the database.
   * 
   * <br/>
   * <b>Precondition:</b> key != null <br/>
   * <b>Precondition:</b> !key.trim().equals("") <br/>
   * <b>Precondition:</b> type != null <br/>
   * <b>Precondition:</b> !type.trim().equals("") <br/>
   * <b>Postcondition:</b> BusinessDAO representing the item in the database of
   * the given key and type is returned
   * 
   * @param type
   *          fully qualified type of an item in the database
   * @param key
   *          key of an item in the database
   * 
   * @return BusinessDAO instance of the given type and key
   */
  public static BusinessDAOIF get(String type, String key)
  {
    return (BusinessDAOIF) EntityDAO.get(type, key);
  }

  /**
   * Returns a new BusinessDAO with the attributes defined for the class with
   * the given type. Some attributes will contain default values, as defined in
   * the attribute metadata. Otherwise, the attributes will be blank.
   * 
   * <br/>
   * <b>Precondition:</b> classType parameter represents a valid classType in
   * the database. <br/>
   * <b>Precondition:</b> classType must not be abstract, otherwise a DataAccess
   * exception will be thrown <br/>
   * <b>Postcondition:</b> BusinessDAO returned is an instance of the given
   * classType. The BusinessDAO contains all attributes defined for that
   * classType.
   * 
   * @param classType
   *          Valid classType. Examples: Constants.USER, FOLDER
   * @return BusinessDAO instance of the given class
   * @throws com.runwaysdk.dataaccess.DataAccessException
   *           if the class is not valid or is abstract
   */
  public static BusinessDAO newInstance(String classType)
  {
    return BusinessDAOFactory.newInstance(classType);
  }

  public String toString()
  {
    return '[' + getType() + ']';
  }
}
