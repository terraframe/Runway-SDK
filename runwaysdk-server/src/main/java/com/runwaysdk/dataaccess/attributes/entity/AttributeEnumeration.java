/**
 * Copyright (c) 2013 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Created on Jun 22, 2005
 */
package com.runwaysdk.dataaccess.attributes.entity;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;

import com.runwaysdk.dataaccess.AttributeEnumerationIF;
import com.runwaysdk.dataaccess.BusinessDAO;
import com.runwaysdk.dataaccess.DataAccessException;
import com.runwaysdk.dataaccess.EntityDAO;
import com.runwaysdk.dataaccess.EnumerationItemDAO;
import com.runwaysdk.dataaccess.EnumerationItemDAOIF;
import com.runwaysdk.dataaccess.MdAttributeConcreteDAOIF;
import com.runwaysdk.dataaccess.MdAttributeDAOIF;
import com.runwaysdk.dataaccess.MdAttributeEnumerationDAOIF;
import com.runwaysdk.dataaccess.MdEnumerationDAOIF;
import com.runwaysdk.dataaccess.attributes.AttributeException;
import com.runwaysdk.dataaccess.attributes.AttributeSet;
import com.runwaysdk.dataaccess.attributes.AttributeValueException;
import com.runwaysdk.dataaccess.attributes.EmptyValueProblem;
import com.runwaysdk.dataaccess.cache.DataNotFoundException;
import com.runwaysdk.dataaccess.database.Database;
import com.runwaysdk.dataaccess.database.ServerIDGenerator;

/**
 * @author nathan
 * 
 */
public class AttributeEnumeration extends Attribute implements AttributeEnumerationIF, AttributeSet
{
  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = 5209447830611126011L;

  private Set<String>       enumItemIdSet;

  /**
   * 
   * @param name
   * @param mdAttributeKey
   *          key of the defining attribute metadata
   * @param definingEntity
   * @param value
   */
  public AttributeEnumeration(String name, String mdAttributeKey, String definingEntity, String value)
  {
    super(name, mdAttributeKey, definingEntity, value);

    this.initSetId();

    this.enumItemIdSet = new TreeSet<String>();
  }

  /**
   * 
   * @param name
   * @param mdAttributeKey
   *          key of the defining attribute metadata
   * @param definingEntityType
   * @param value
   */
  public AttributeEnumeration(String name, String mdAttributeKey, String definingEntityType, String value, Set<String> enumItemIdList)
  {
    super(name, mdAttributeKey, definingEntityType, value);

    this.initSetId();

    this.enumItemIdSet = enumItemIdList;
  }

  /**
   * Initializes the setId, which is the value of this attribute.
   * 
   */
  private void initSetId()
  {
    if (this.value.trim().equals(""))
    {
      this.value = ServerIDGenerator.nextID();
    }
  }

  /**
   * Returns a cached list of mappings between this object and enumeration
   * items. If an enumeration item is removed from the master list, this cache
   * may still contain an ID to the item.
   * 
   * @return Returns the enumItemIdList.
   */
  public synchronized Set<String> getCachedEnumItemIdSet()
  {
    return this.enumItemIdSet;
  }

  /**
   * 
   * @return
   */
  public synchronized String getCachedEnumItemIds()
  {
    int i = 0;
    String cacheColumnValues = "";

    for (String enumItemId : enumItemIdSet)
    {
      if (i++ != 0)
      {
        cacheColumnValues += ",";
      }
      cacheColumnValues += enumItemId;
    }
    return cacheColumnValues;
  }

  /**
   * Returns a list of mappings between this object and enumeration items from
   * the database and will OVERWRITE the values that have been added but not
   * applied.
   * 
   * @return Returns the enumItemIdList.
   */
  public synchronized Set<String> getEnumItemIdList()
  {
    this.refreshEnumIdList(true);
    return this.enumItemIdSet;
  }

  /**
   * Initializes a local cache in this object of enumeration mappings - DO NOT
   * CALL.
   * 
   * @param enumIdList
   */
  public synchronized void initEnumMappingCache(String enumIdList)
  {
    StringTokenizer stringTokenizer = new StringTokenizer(enumIdList, ",", false);
    while (stringTokenizer.hasMoreTokens())
    {
      this.enumItemIdSet.add(stringTokenizer.nextToken());
    }
  }

  /**
   * Refresh the local cache from the database;
   * 
   * @param useCache
   *          true if the cache has been initialized.
   */
  private void refreshEnumIdList(boolean useCache)
  {
    MdAttributeEnumerationDAOIF mdAttributeEnumerationIF = (MdAttributeEnumerationDAOIF) this.getMdAttribute();
    MdEnumerationDAOIF mdEnumerationIF = mdAttributeEnumerationIF.getMdEnumerationDAO();
    this.enumItemIdSet = Database.getEnumItemIds(mdEnumerationIF.getTableName(), this.getValue());
  }

  /**
   * Sets the enumeration to contain only <code>value</code>, regardless of
   * multiplicity or previous value.
   * 
   * @param value
   *          New value to be set for <b><code>this</b></code>
   * @return <code>true</code> if the value is set successfully
   * @throws DataAccessException
   */
  public synchronized void setValue(String value)
  {
    if (enumItemIdSet.size() == 1 && enumItemIdSet.contains(value))
    {
      return;
    }
    else
    {
      MdAttributeEnumerationDAOIF mdAttribute = this.getMdAttribute();
      this.validate(value, mdAttribute, true);

      if (!this.getContainingComponent().isNew())
      {
        // refresh the local enumeration mapping cache
        this.refreshEnumIdList(true);
      }

      this.clearItems();
      enumItemIdSet.add(value);

      this.setModified(true);
    }
  }

  /**
   * Returns the BusinessDAO that defines the this attribute.
   * 
   * <br>
   * <b>Precondition: </b> true <br>
   * <b>Postcondition: </b> true
   * 
   * @return BusinessDAO that defines the this attribute
   */
  public MdAttributeEnumerationDAOIF getMdAttribute()
  {
    return (MdAttributeEnumerationDAOIF) super.getMdAttribute();
  }

  /**
   * Returns the concrete attribute metadata that defines this attribute. If
   * this is defined by aa concrete attribute, this object is returned. If it is
   * a virtual attribute, then the concrete attribute it references is returned.
   * 
   * @return MdAttributeEnumerationDAOIF that defines the this attribute
   */
  public MdAttributeEnumerationDAOIF getMdAttributeConcrete()
  {
    return this.getMdAttribute();
  }

  /**
   * Sets the default value of the attribute, if any is defined. Basically this
   * skips the mutible attribute test, as that test will crash if called before
   * the containing object has been defined.
   * 
   * @param value
   *          New value to be set for <b><code>this</b></code>
   * @return <code>true</code> if the value is set successfully
   * @throws DataAccessException
   */
  public synchronized void setDefaultValue(String value)
  {
    MdAttributeEnumerationDAOIF mdAttribute = (MdAttributeEnumerationDAOIF) this.getMdAttribute();
    this.validate(value, mdAttribute, false);

    this.clearItems();
    enumItemIdSet.add(value);

    this.setModified(true);
  }

  /**
   * Adds an item to an enumerated atribute. If the attribute does not allow
   * multiplicity, the <code>enumItemID</code> replaces the previous item.
   * 
   * @param enumItemID
   *          The ID of the item to be added to the enumerated attribute
   * @return <code>true</code> if the item is successfully added
   */
  public synchronized boolean addItem(String enumItemID)
  {
    if (enumItemIdSet.contains(enumItemID))
    {
      return true;
    }

    MdAttributeEnumerationDAOIF mdAttribute = (MdAttributeEnumerationDAOIF) this.getMdAttribute();
    this.validate(enumItemID, mdAttribute, true);

    if (!mdAttribute.selectMultiple())
    {
      this.clearItems();
    }

    enumItemIdSet.add(enumItemID);

    this.setModified(true);
    return true;
  }

  /**
   * Replaces the items of an enumerated attribute. If the attribute does not
   * allow multiplicity, then the {@code enumItemIDs} collection must contain
   * only one item.
   * 
   * @param name
   *          Name of the enumerated attribute
   * @param enumItemIDs
   *          Collection of enumerated item ids
   * 
   * @return Flag indicating if a modification to the existing enumerated item
   *         occured.
   */
  public synchronized boolean replaceItems(Collection<String> enumItemIDs)
  {
    MdAttributeEnumerationDAOIF mdAttribute = (MdAttributeEnumerationDAOIF) this.getMdAttribute();

    // Validate all of the items in the collection
    for (String enumItemID : enumItemIDs)
    {
      this.validate(enumItemID, mdAttribute, true);
    }

    if (!mdAttribute.selectMultiple() && enumItemIDs.size() != 1)
    {
      String error = "Unable to add multiple items for the select single enumerated Attribute [" + getName() + "] on type [" + getDefiningClassType() + "]";

      throw new DataAccessException(error);
    }

    boolean intersectModification = enumItemIdSet.retainAll(enumItemIDs);
    boolean addModification = enumItemIdSet.addAll(enumItemIDs);

    this.setModified(intersectModification || addModification);

    return ( intersectModification || addModification );
  }

  /**
   * Removes an item from an enumerated attribute
   * 
   * @param enumItemID
   *          The ID of the item to be removed from the enumerated attribute
   */
  public synchronized void removeItem(String enumItemID)
  {
    this.enumItemIdSet.remove(enumItemID);
    this.setModified(true);
  }

  /**
   * 
   * @param enumItemID
   */
  public synchronized void clearItems()
  {
    this.enumItemIdSet.clear();
    this.setModified(true);
  }

  /**
   *
   */
  public synchronized void validateRequired(String valueToValidate, MdAttributeConcreteDAOIF mdAttributeIF)
  {
    // make sure an enumeration Item has been mapped to this value if a value is
    // required
    if (mdAttributeIF.isRequired())
    {
      if (enumItemIdSet.size() == 0)
      {
        String error = "Attribute [" + getName() + "] on type [" + getDefiningClassType() + "] requires a value";
        EmptyValueProblem problem = new EmptyValueProblem(this.getContainingComponent().getProblemNotificationId(), mdAttributeIF.definedByClass(), mdAttributeIF, error, this);
        problem.throwIt();
      }
    }
  }

  /**
   * This is used to validate the default value of the given {@link#
   * MdAttributeIF}. Runs validation tests that are common to all Attribute
   * classes, but not the required attribute test.
   * 
   * @param mdAttributeIF
   * @param valueToValidate
   *          the String value to be validated
   * @return true if the value is valid for all common tests
   * @throws AttributeException
   *           if the attribute is not valid.
   */
  public void validate(MdAttributeDAOIF mdAttributeIF, String valueToValidate)
  {
    super.validate(valueToValidate, mdAttributeIF);

    validate(valueToValidate, (MdAttributeEnumerationDAOIF) mdAttributeIF, false);
  }

  /**
   * <br>
   * <b>Precondition</b> this.getCContainingComponent() != null && checkMutable
   * == true
   * 
   * @param enumItemID
   * @param mdAttribute
   * @return
   */
  private void validate(String enumItemID, MdAttributeEnumerationDAOIF mdAttribute, boolean checkMutable)
  {
    MdEnumerationDAOIF mdEnumeration = mdAttribute.getMdEnumerationDAO();

    if (checkMutable)
    {
      EntityDAO containingEntity = (EntityDAO) this.getContainingComponent();
      if (containingEntity.isAppliedToDB())
      {
        this.validateMutable(mdAttribute);
      }
    }
    if (mdEnumeration != null)
    {
      if (!mdEnumeration.isValidEnumerationItem(enumItemID))
      {
        String error = "[" + enumItemID + "] is not a valid value for the enumerated Attribute [" + getName() + "] on type [" + getDefiningClassType() + "]";
        throw new AttributeValueException(error, this, enumItemID);
      }
    }
  }

  /**
   * 
   * @return
   */
  // Thread refactor - this.enumItemIdList needs to be made thread safe.
  public synchronized EnumerationItemDAOIF[] dereference()
  {
    EnumerationItemDAOIF[] businessDAOArray = new EnumerationItemDAO[this.enumItemIdSet.size()];
    Set<String> refreshedItemIdSet = new TreeSet<String>();
    int i = 0;

    for (String enumItemId : this.enumItemIdSet)
    {
      // structs cannot be used to define an enumeration
      try
      {
        if (enumItemId != null)
        {
          businessDAOArray[i++] = EnumerationItemDAO.get((String) enumItemId);
          refreshedItemIdSet.add(enumItemId);
        }
        else
        {
          i++;
        }
      }
      catch (DataNotFoundException ex)
      {
        // Cached enums can still hold items that have been dropped. Ignore
        // items that aren't found.
        ex.printStackTrace();
      }
    }
    this.enumItemIdSet = refreshedItemIdSet;

    return businessDAOArray;
  }

  /**
   * Clears all enumerated items.
   * 
   */
  protected void reset()
  {
    MdAttributeEnumerationDAOIF mdAttributeEnumerationIF = null;
    mdAttributeEnumerationIF = (MdAttributeEnumerationDAOIF) this.getMdAttribute();

    MdEnumerationDAOIF mdEnumerationIF = mdAttributeEnumerationIF.getMdEnumerationDAO();
    Database.deleteSetIdFromLinkTable(mdEnumerationIF.getTableName(), this.getValue());
  }

  /**
   * Cleans up any object that references this attribute in some way. Removes
   * mappings between this attribute and any enumeration items it pointed to.
   * <b>Precondition: </b> this attribute MUST be a member of the given
   * EntityDAO <br>
   */
  public void removeReferences(EntityDAO enitityObject, boolean businessContext)
  {
    super.removeReferences(enitityObject, businessContext);
    this.reset();
  }

  /**
   * Create mapping in the database between this attribute and the enummeration
   * items it points to.
   * 
   * <b>Precondition: </b> this MdAttribute MUST be the metadata of this
   * attribute. <br>
   * <b>Precondition: </b> this.enumItemIdList has been refreshed and is not a
   * stale cache, meaning every item it contains represents a valid mapping to a
   * valid item.<br>
   */
  public synchronized void initReferences(MdAttributeConcreteDAOIF mdAttributeIF)
  {
    MdAttributeEnumerationDAOIF mdAttributeEnumerationIF = (MdAttributeEnumerationDAOIF) mdAttributeIF;
    MdEnumerationDAOIF mdEnumerationIF = mdAttributeEnumerationIF.getMdEnumerationDAO();

    String tableName = mdEnumerationIF.getTableName();

    // validate the local cache.
    Set<String> refreshedItemIdList = new TreeSet<String>();

    for (String enumItemId : this.enumItemIdSet)
    {
      // structs cannot be used to define an enumeration
      try
      {
        BusinessDAO.get(enumItemId);
        // Exception not thrown, meaning that the item has not been deleted.
        refreshedItemIdList.add(enumItemId);
      }
      catch (DataNotFoundException ex)
      {
        // Cached enums can still hold items that have been dropped. Ignore
        // items that aren't found.
      }
    }

    this.enumItemIdSet = refreshedItemIdList;

    List<String> sqlInsertStatements = new LinkedList<String>();
    for (String enumItemId : this.enumItemIdSet)
    {
      sqlInsertStatements.add(Database.buildAddItemStatement(tableName, this.getValue(), enumItemId));
    }

    Database.executeBatch(sqlInsertStatements);
  }

  /**
   * Updates the mapping in the database between this attribute and the
   * enummeration items it points to.
   * 
   * <b>Precondition: </b> this MdAttribute MUST be the metadata of this
   * attribute. <br>
   */
  public synchronized void updateReferences(MdAttributeConcreteDAOIF mdAttribute)
  {
    // Clear any existing enumeration item mappings
    this.reset();

    // Create the mappings with the enumeration items that this attribute
    // currently points to.
    this.initReferences(mdAttribute);
  }

  /**
   * Returns a deep clone of this attribute.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> true
   * 
   * @return a deep clone of this Attribute
   */
  public synchronized Attribute attributeClone()
  {
    Set<String> cloneSet = new TreeSet<String>(this.enumItemIdSet);

    return new AttributeEnumeration(this.getName(), this.mdAttributeKey, this.getDefiningClassType(), new String(this.getRawValue()), cloneSet);
  }

  /**
   * Returns a deep clone of this attribute.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> true
   * 
   * @return a deep clone of this Attribute
   */
  public synchronized Attribute attributeCopy()
  {
    Set<String> cloneSet = new TreeSet<String>(this.enumItemIdSet);

    return new AttributeEnumeration(this.getName(), this.mdAttributeKey, this.getDefiningClassType(), ServerIDGenerator.nextID(), cloneSet);
  }
}
