/**
 * Copyright (c) 2022 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Created on Aug 11, 2004
 */
package com.runwaysdk.dataaccess;

import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.runwaysdk.business.Business;
import com.runwaysdk.business.BusinessFacade;
import com.runwaysdk.business.generation.GenerationUtil;
import com.runwaysdk.constants.BusinessInfo;
import com.runwaysdk.constants.EntityInfo;
import com.runwaysdk.dataaccess.attributes.entity.Attribute;
import com.runwaysdk.dataaccess.cache.DataNotFoundException;
import com.runwaysdk.dataaccess.cache.ObjectCache;
import com.runwaysdk.dataaccess.database.Database;
import com.runwaysdk.dataaccess.database.RelationshipDAOFactory;
import com.runwaysdk.dataaccess.metadata.DeleteContext;
import com.runwaysdk.dataaccess.metadata.MdBusinessDAO;
import com.runwaysdk.dataaccess.metadata.MdElementDAO;
import com.runwaysdk.dataaccess.metadata.MdRelationshipDAO;
import com.runwaysdk.dataaccess.transaction.LockRelationship;
import com.runwaysdk.util.IdParser;

/**
 * A Relationship has a parent and a child BusinessDAO. It also has a collection
 * of attributes. A relationship's type determines the number and type of
 * BusinessDAOs that can be parents and children in the relationship.
 * 
 * @author nathan
 * @version $Revision: 1.88 $
 * @since 1.4s
 */
public class RelationshipDAO extends ElementDAO implements RelationshipDAOIF, Serializable
{
  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = 796338853954464656L;

  /**
   * oid of the parent BusinessDAO in the relationship. <br/>
   * <b>invariant </b> parentOid != null <br/>
   * <b>invariant </b> !parentOid.trim().equals("") <br/>
   */
  private String            parentOid;
  
  /**
   * The old oid of the parent if the parent has changed.
   */
  private String            oldParentOid;

  /**
   * oid of the child BusinessDAO in the relationship. <br/>
   * <b>invariant </b> childOid != null <br/>
   * <b>invariant </b> !childOid().equals("") <br/>
   */
  private String            childOid;
  
  /**
   * The old oid of the parent if the child has changed.
   */
  private String            oldChildOid;

  /**
   *
   */
  public RelationshipDAO(String parentOid, String childOid, Map<String, Attribute> attributeMap, String relationshipType)
  {
    super(attributeMap, relationshipType);
    this.parentOid = parentOid;
    this.childOid = childOid;
    this.oldParentOid = null;
    this.oldChildOid = null;
  }

  /**
   * @param parentOid
   *          Overwrites the parent oid if this relationship is new and has not
   *          been applied to the database
   */
  public void overwriteParentOid(String parentOid)
  {
    if (this.isNew() && !this.isAppliedToDB())
    {
      this.parentOid = parentOid;
    }
  }

  /**
   * @param childOid
   *          Overwrites the child oid if this relationship is new and has not
   *          been applied to the database
   */
  public void overwriteChildOid(String childOid)
  {
    if (this.isNew() && !this.isAppliedToDB())
    {
      this.childOid = childOid;
    }
  }

  /**
   * Checks the Relationship for several validity constraints: the classes of
   * the parent and child, as well as the cardinality of the parent and child
   * for this relationship.
   */
  protected void validate()
  {
    super.validate();

    // No need to check for cardinality violations if we are simply modifying
    // attributes
    // on this relationship.
    if (!this.isNew() || this.isAppliedToDB())
    {
      return;
    }

    MdRelationshipDAOIF mdRelationshipIF = this.getMdRelationshipDAO();
    MdBusinessDAOIF expectedParentMdBusinessDAOIF = mdRelationshipIF.getParentMdBusiness();
    MdBusinessDAOIF expectedChildMdBusinessDAOIF = mdRelationshipIF.getChildMdBusiness();

    String expectedParentClass = expectedParentMdBusinessDAOIF.definesType();
    String expectedChildClass = expectedChildMdBusinessDAOIF.definesType();

    String parentMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.parentOid);
    String childMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.childOid);

    MdBusinessDAOIF actualParentMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(parentMdTypeRootId);
    MdBusinessDAOIF actualChildMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(childMdTypeRootId);

    String actualParentClass = actualParentMdBusinessDAOIF.definesType();
    String actualChildClass = actualChildMdBusinessDAOIF.definesType();

    // Ensure that the parent and child exist
    BusinessDAO.get(this.parentOid);
    BusinessDAO.get(this.childOid);

    // Check if the type of the parent matches what is expected
    if (!expectedParentClass.equals(BusinessInfo.CLASS))
    {
      if (!MdElementDAO.isSubEntity(actualParentClass, expectedParentClass))
      {
        String error = "Relationship [" + mdRelationshipIF.definesType() + "] requires a parent of class [" + expectedParentMdBusinessDAOIF.definesType() + "]. The supplied value is class [" + actualParentClass + "].";
        throw new UnexpectedTypeException(error);
      }
    }

    // Class-check the child against the spec in the Relationship
    if (!expectedChildClass.equals(BusinessInfo.CLASS))
    {
      if (!MdElementDAO.isSubEntity(actualChildClass, expectedChildClass))
      {
        String error = "Relationship [" + mdRelationshipIF.definesType() + "] requires a child of class [" + expectedChildMdBusinessDAOIF.definesType() + "]. The supplied value is class [" + actualChildClass + "].";
        throw new UnexpectedTypeException(error);
      }
    }

    this.validateCardinality(mdRelationshipIF);

    for (MdRelationshipDAOIF mdParentMdRelationshipIF : mdRelationshipIF.getSuperClasses())
    {
      this.validateCardinality((MdRelationshipDAOIF) mdParentMdRelationshipIF);
    }

  }

  /**
   * 
   * @param mdRelationshipIF
   */
  private void validateCardinality(MdRelationshipDAOIF mdRelationshipIF)
  {
    String parentCardinality = mdRelationshipIF.getParentCardinality();
    String childCardinality = mdRelationshipIF.getChildCardinality();

    if (!parentCardinality.equals("*"))
    {
      long existingParentsForChild = Database.getParentCountForChild(childOid, mdRelationshipIF.getTableName());

      int cardinality = Integer.parseInt(parentCardinality);

      if (existingParentsForChild >= cardinality)
      {
        String childMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.childOid);
        MdBusinessDAOIF childMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(childMdTypeRootId);

        String error = "A [" + childMdBusinessDAOIF.definesType() + "] can only be in " + cardinality + " [" + mdRelationshipIF.definesType() + "] relationships.  The requested operation " + "would put it in " + ( cardinality + 1 ) + ".";

        MdBusinessDAOIF otherMdBusinessIF = mdRelationshipIF.getParentMdBusiness();

        throw new RelationshipCardinalityException(error, childMdBusinessDAOIF, cardinality, mdRelationshipIF, this.childOid, otherMdBusinessIF);

      }
    }

    if (!childCardinality.equals("*"))
    {
      long existingChildrenForParent = Database.getChildCountForParent(this.parentOid, mdRelationshipIF.getTableName());

      int cardinality = Integer.parseInt(childCardinality);

      if (existingChildrenForParent >= cardinality)
      {
        String parentMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.parentOid);
        MdBusinessDAOIF parentMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(parentMdTypeRootId);

        String error = "A [" + parentMdBusinessDAOIF.definesType() + "] can only be in " + cardinality + " [" + mdRelationshipIF.definesType() + "] relationships.  The requested operation " + "would put it in " + ( cardinality + 1 ) + ".";

        MdBusinessDAOIF otherMdBusinessIF = mdRelationshipIF.getChildMdBusiness();

        throw new RelationshipCardinalityException(error, parentMdBusinessDAOIF, cardinality, mdRelationshipIF, this.parentOid, otherMdBusinessIF);
      }
    }

  }

  /**
   * Returns the OID of the Relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> The state of the Relationship does not change <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return The OID of the Relationship
   */
  public String getOid()
  {
    return this.getAttributeIF(EntityInfo.OID).getValue();
  }
  
  /**
   * Clears the old ids, to be called only when this object has been applied to the global
   * cache at the end of a transaction.
   */
  public void clearOldRelIds()
  {
    this.oldParentOid = null;
    this.oldChildOid = null;
  }

  /**
   * Returns the oid of the parent BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return oid of the parent BusinessDAO in this relationship
   */
  public String getParentOid()
  {
    return this.parentOid;
  }

  /**
   * Sets the parent oid to a new oid. ONLY CALL THIS ONCE IN A TRANSACTION!
   * 
   * @param newParentOid
   */
  public void setParentOid(String newParentOid)
  {
    if (this.isAppliedToDB() && !this.getParentOid().equals(newParentOid))
    {
      this.oldParentOid = this.parentOid;  
      this.parentOid = newParentOid;
    }
  }
  
  /**
   * @return the oldParentOid
   */
  public String getOldParentOid()
  {
    return oldParentOid;
  }

  /**
   * @param oldParentOid the oldParentOid to set
   */
  public void setOldParentOid(String oldParentOid)
  {
    this.oldParentOid = oldParentOid;
  }
  
  /**
   * Return true if the child oid has changed, false otherwise.
   * 
   * @return true if the child oid has changed, false otherwise.
   */
  public boolean hasChildOidChanged()
  {
    if (this.oldChildOid != null && 
        !this.oldChildOid.equals(this.childOid))
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  /**
   * Return true if the parent oid has changed, false otherwise.
   * 
   * @return true if the parent oid has changed, false otherwise.
   */
  public boolean hasParentOidChanged()
  {
    if (this.oldParentOid != null && 
        !this.oldParentOid.equals(this.parentOid))
    {
      return true;
    }
    else
    {
      return false;
    }
  }
  
  /**
   * Returns the parent BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return the parent BusinessDAO in this relationship
   */
  public BusinessDAOIF getParent()
  {
    return BusinessDAO.get(this.parentOid);
  }

  /**
   * Returns the oid of the child BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return oid of the child BusinessDAO in this relationship
   */
  public String getChildOid()
  {
    return this.childOid;
  }

  /**
   * Sets the child oid to a new oid. ONLY CALL THIS ONCE IN A TRANSACTION!
   * 
   * @param newChildOid
   */
  public void setChildOid(String newChildOid)
  {
    if (this.isAppliedToDB() && !this.getChildOid().equals(newChildOid))
    {
      this.oldChildOid = this.childOid;  
      this.childOid = newChildOid;
    }
  }
  
  /**
   * @return the oldChildOid
   */
  public String getOldChildOid()
  {
    return oldChildOid;
  }

  /**
   * @param oldChildOid the oldChildOid to set
   */
  public void setOldChildOid(String oldChildOid)
  {
    this.oldChildOid = oldChildOid;
  }
  
  /**
   * Returns the child BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return the child BusinessDAO in this relationship
   */
  public BusinessDAOIF getChild()
  {
    return BusinessDAO.get(this.childOid);
  }

  /**
   * Returns the metadata BusinessDAO describing this relationship type.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return the metadata BusinessDAO describing this relationship type
   */
  public MdRelationshipDAOIF getMdRelationshipDAO()
  {
    return MdRelationshipDAO.getMdRelationshipDAO(this.getType());
  }

  /**
   * Applies the state of this Relationship to the database. If this is a new
   * Relationship, then records are created in the database and an OID is
   * created. If this is not a new Relationship, then records are modified in
   * the database.
   * 
   * <br/>
   * <b>Precondition: </b> Attribues must have correct values as defined in
   * their meta data. <br/>
   * <b>Postcondition: </b> state of the Relationship is preserved in the
   * database. <br/>
   * <b>Postcondition: </b> return value is not null
   * 
   * @return OID of the Relationship.
   * @throws DataAccessException
   *           if an attribute contains a value that is not correct with respect
   *           to the metadata.
   */
  public String save(boolean save)
  {
    ( LockRelationship.getLockRelationship() ).relLock(this.parentOid, this.childOid);

    if (this.isNew() && !this.isAppliedToDB())
    {
      // Ensure that the parent and child exist
      BusinessDAO.get(this.parentOid);
      BusinessDAO.get(this.childOid);
    }

    super.save(save);

    // Aspect will release the lock after the enclosing transaction is complete.

    return this.getOid();
  }

  /**
   * Deletes the given relationship from the database.
   * 
   * <br/>
   * <b>Precondition: </b> isNew == false <br/>
   * <b>Postcondition: </b> Relationship is deleted from the database
   * 
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   * 
   */
  public void delete(DeleteContext context)
  {
    super.delete(context);

    MdRelationshipDAOIF mdRelationshipIF = this.getMdRelationshipDAO();
    if (mdRelationshipIF.isComposition())
    {
      BusinessDAOIF childDAOIF = this.getChild();

      if (context.isBusinessContext() && !GenerationUtil.isSkipCompileAndCodeGeneration(childDAOIF.getMdBusinessDAO()))
      {
        Business business = BusinessFacade.get(childDAOIF);
        business.delete();
      }
      else
      {
        BusinessDAO childObject = childDAOIF.getBusinessDAO();
        childObject.delete();
      }
    }
  }

  /**
   * Return the Relationship instance with the given oid. Request is routed to
   * the collection responsible for relationships of the given type.
   * 
   * <br/>
   * <b>Precondition:</b> relId != null <br/>
   * <b>Precondition:</b> !relId.trim().equals("")
   * 
   * @param relId
   *          oid of a Relationship
   * @return Relationship object with the given oid
   */
  public static RelationshipDAOIF get(String oid)
  {
    return ObjectCache.getRelationshipDAO(oid);
  }

  /**
   * Return the Relationship instance of the given type with the given key.
   * 
   * <br/>
   * <b>Precondition:</b> type != null <br/>
   * <b>Precondition:</b> !type.trim().equals("") <br/>
   * <b>Precondition:</b> key != null <br/>
   * <b>Precondition:</b> !key.trim().equals("")
   * 
   * @param type
   *          Fully qualified type of a Relationship
   * @param key
   *          The key of a Relationship
   * 
   * @return RelationshipDAO of the given type with the given key
   */
  public static RelationshipDAOIF get(String type, String key)
  {
    return (RelationshipDAOIF) EntityDAO.get(type, key);
  }

  /**
   * Returns a list of relationship objects of the given type with the given
   * parent and child ids. Throws an exception if the relationship does not
   * exist.
   * 
   * <b>Precondition:</b>Assumes that the given relationshipType is concrete.
   * 
   * @param parentOid
   * @param childOid
   * @param relationshipType
   * @return list of relationship objects of the given type with the given
   *         parent and child ids. Throws an exception if the relationship does
   *         not exist.
   */
  public static List<RelationshipDAOIF> get(BusinessDAOIF parentObjectIF, BusinessDAOIF childObjectIF, String relationshipType)
  {
    return get(parentObjectIF.getOid(), childObjectIF.getOid(), relationshipType);
  }

  /**
   * Returns a list of relationship objects of the given type with the given
   * parent and child ids. Throws an exception if the relationship does not
   * exist.
   * 
   * <b>Precondition:</b>Assumes that the given relationshipType is concrete.
   * 
   * @param parentOid
   * @param childOid
   * @param relationshipType
   * @return list of relationship objects of the given type with the given
   *         parent and child ids. Throws an exception if the relationship does
   *         not exist.
   */
  public static List<RelationshipDAOIF> get(String parentOid, String childOid, String relationshipType)
  {
    List<RelationshipDAOIF> relaitonshipIFList = RelationshipDAOFactory.get(parentOid, childOid, relationshipType);

    if (relaitonshipIFList.size() == 0)
    {
      MdRelationshipDAOIF mdRelationship = MdRelationshipDAO.getMdRelationshipDAO(relationshipType);
      String errMsg = "A relationship of type [" + relationshipType + "] with parent oid [" + parentOid + "] and child oid [" + childOid + "] could not be found.";
      throw new DataNotFoundException(errMsg, mdRelationship);
    }

    return relaitonshipIFList;
  }

  /**
   * 
   * @param relationshipType
   * @return
   */
  public static RelationshipDAO newInstance(String parentOid, String childOid, String relationshipType)
  {
    return RelationshipDAOFactory.newInstance(parentOid, childOid, relationshipType);
  }

  /**
   * Returns a clone of the given RelationshipDAO instance. The cloned instance
   * can be applied to the database.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> Clone (deep copy) of this RelationshipDAO instance is
   * returned.
   * 
   * @return a clone of the given RelationshipDAO instance
   */
  public RelationshipDAO clone()
  {
    HashMap<String, Attribute> newAttrList = new HashMap<String, Attribute>();

    // clone all of the attributes
    for (Attribute attrOld : this.getObjectState().getAttributeMap().values())
    {
      Attribute attrNew = attrOld.attributeClone();
      newAttrList.put(attrNew.getName(), attrNew);
    }
    RelationshipDAO clonedObject = RelationshipDAOFactory.factoryMethod(this.getParentOid(), this.getChildOid(), newAttrList, new String(this.componentType), true);

    clonedObject.setIsNew(this.isNew());
    clonedObject.setAppliedToDB(this.isAppliedToDB());
    return clonedObject;
  }

  /**
   * Returns a copy of the given RelationshipDAO instance, with a new oid and
   * mastered at the current site. The state of the object is new and has not
   * been applied to the database.
   * 
   * @return a copy of the given RelationshipDAO instance
   */
  public RelationshipDAO copy()
  {
    HashMap<String, Attribute> newAttrMap = new HashMap<String, Attribute>();

    RelationshipDAO copiedObject = RelationshipDAO.newInstance(this.getParentOid(), this.getChildOid(), this.getType());

    // clone all of the attributes
    for (Attribute attrOld : this.getObjectState().getAttributeMap().values())
    {
      if (! ( attrOld ).getMdAttribute().isSystem())
      {
        Attribute attrNew = attrOld.attributeCopy();
        attrNew.setContainingComponent(copiedObject);
        newAttrMap.put(attrNew.getName(), attrNew);
      }
    }

    // This should overwrite the non-system attributes, such as oid and site
    // master
    copiedObject.getObjectState().getAttributeMap().putAll(newAttrMap);

    return copiedObject;
  }

  @Override
  public boolean equals(Object obj)
  {
    if (obj instanceof RelationshipDAO)
    {
      RelationshipDAO r1 = (RelationshipDAO) obj;

      return this.getOid().equals(r1.getOid());
    }

    return false;
  }

  public int hashCode()
  {
    return this.getOid().hashCode();
  }

  /**
   * Returns a deep cloned-copy of this Relationship
   */
  public RelationshipDAO getRelationshipDAO()
  {
    // Only clone the object if this object comes from a cache.
    if (this.isFromCache())
    {
      return this.clone();
    }
    else
    {
      return this;
    }
  }
  
  /**
   * Facade method.
   * 
   * @param relationshipDAOIF
   * @return the oldParentOid
   */
  public static String getOldParentOid(RelationshipDAOIF relationshipDAOIF)
  {
    return ((RelationshipDAO)relationshipDAOIF).getOldParentOid();
  }
  
  /**
   * Facade method.
   * 
   * @param relationshipDAOIF
   * @return the oldChildOid
   */
  public static String getOldChildOid(RelationshipDAOIF relationshipDAOIF)
  {
    return ((RelationshipDAO)relationshipDAOIF).getOldChildOid();
  }
}
