/**
 * Copyright (c) 2022 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Created on Sep 1, 2005
 *
 */
package com.runwaysdk.dataaccess;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.runwaysdk.constants.EnumerationMasterInfo;
import com.runwaysdk.constants.MdAttributeEnumerationInfo;
import com.runwaysdk.constants.MdAttributeReferenceInfo;
import com.runwaysdk.constants.MdEnumerationInfo;
import com.runwaysdk.constants.RelationshipTypes;
import com.runwaysdk.dataaccess.attributes.entity.Attribute;
import com.runwaysdk.dataaccess.cache.ObjectCache;
import com.runwaysdk.dataaccess.database.Database;
import com.runwaysdk.dataaccess.metadata.DeleteContext;
import com.runwaysdk.dataaccess.metadata.MdAttributeConcreteDAO;
import com.runwaysdk.dataaccess.metadata.MdEnumerationDAO;
import com.runwaysdk.query.BusinessDAOQuery;
import com.runwaysdk.query.OIterator;
import com.runwaysdk.query.QueryFactory;


/**
 * @author nathan
 *
 */
public class EnumerationItemDAO extends BusinessDAO implements EnumerationItemDAOIF, SpecializedDAOImplementationIF
{
  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = -7685565647925321732L;

  /**
   * Returns and object of the specified master type
   * with the specified enumeration name from the database.
   *
   * @param masterType The type of the Enumeration Master
   * @param enumName The name of the Enumerated item.
   * @return EnumerationItem representing the enumerated item in the database
   */
  public static EnumerationItemDAO getEnumeration(String masterType, String enumName)
  {
    return ObjectCache.getEnumeration(masterType, enumName);
  }

  /**
   * Constructs a EnumerationItem from the given hashtable of Attributes.
   *
   * <br/><b>Precondition:</b>   attributeMap != null
   * <br/><b>Precondition:</b>   classType != null
   *
   * @param attributeMap
   * @param classType
   */
  public EnumerationItemDAO(Map<String, Attribute> attributeMap, String classType)
  {
    super(attributeMap, classType);
  }

  /**
   * Returns the enum name of this item.
   * @return enum name of this item.
   */
  public String getName()
  {
    return this.getAttributeIF(EnumerationMasterInfo.NAME).getValue();
  }
  
  public String apply()
  {
    String key = buildKey();
    this.setKey(key);
    
    return super.apply();
  }

  /**
   *Applies the state of this EnumerationItem to the database.  If this is a new EnumerationItem,
   * then records are created in the database and an OID is created.  If this is not a
   * new EnumerationItem, then records are modified in the database.
   *
   * <br/><b>Precondition:</b>   Attribues must have correct values as defined in their meta data.
   * <br/><b>Postcondition:</b>  state of the EnumerationItem is preserved in the database.
   * <br/><b>Postcondition:</b>  return value is not null
   *
   * @param validateRequired ture if attributes should be checked for required values,
   *                         false otherwise.  Basic struct classes may or
   *                         may not need required attributes validated.
   * @return OID of the EnumerationItem.
   * @throws DataAccessException if an attribute contains a value that is not
   *         correct with respect to the metadata.
   */
  public String save(boolean validateRequired)
  {
    // Enumeration item ids are cached on individual attributeEnumerations. If the oid of the enum item has 
    // changed, then so must the cached attributes.
    if (this.hasIdChanged())
    {
      ObjectCache.refreshTheEntireCache();
    }

    boolean isApplied = this.isAppliedToDB();
    
    String returnId = super.save(validateRequired);
    // If this enumeration item is new, map it to any Constatn.MD_ENUMERATION instances that have INCLUDE_ALL set to true
 
    if(isNew() && !isApplied)
    {
      if (!this.isImport())
      {
        MdBusinessDAOIF mdBusinessIF = this.getMdBusinessDAO();
        // Get all of the Constants.MD_ENUMERATION objects that use this EnumerationItem class for enumeration items

        for (RelationshipDAOIF relationship : mdBusinessIF.getChildren(RelationshipTypes.ENUMERATION_ATTRIBUTE.getType()))
        {
          MdEnumerationDAOIF mdEnumerationIF = (MdEnumerationDAOIF) relationship.getChild();

          // If the enumeration is supposed to include all enumeration items of this class, then create a relationship between
          // this newly created enumeration item and the Constants.MD_ENUMERATION definition
          if (mdEnumerationIF.includeAllEnumerationItems())
          {
            mdEnumerationIF.addEnumItem(this);
          }
        }
      }
    }
    else
    {
      Attribute attributeKey = this.getAttribute(MdEnumerationInfo.KEY);
      if (attributeKey.isModified())
      {
        List<RelationshipDAOIF> relList = this.getChildren(RelationshipTypes.ENUMERATION_ATTRIBUTE_ITEM.getType());
        for(RelationshipDAOIF relationshipDAOIF : relList)
        {
          RelationshipDAO relationshipDAO = relationshipDAOIF.getRelationshipDAO();
          MdEnumerationDAOIF mdEnumerationDAOIF = (MdEnumerationDAOIF)relationshipDAO.getParent();
          relationshipDAO.setKey(MdEnumerationDAO.buildEnumerationAttributeItemKey(mdEnumerationDAOIF, this));
          relationshipDAO.apply();
        }
      }
    }

    return returnId;
  }

  /**
   * Builds a key for this enumeration item.  The key is the type plus the enumeration name.
   * @return
   */
  protected String buildKey()
  {
    return buildKey(this.getType(), this.getName());
  }

  /**
   * Builds a key for this enumeration item.  The key is the type plus the enumeration name.
   * @return
   */
  public static String buildKey(String type, String enumName)
  {
    return type+"."+enumName;
  }

  /**
   *Deletes this EnumerationItem from the database.  Deletes all parent and child
   * relationships with the given EnumerationItem. It must be a cloned from the
   * original.  See the clone() method for more details.
   *
   * <br/><b>Precondition:</b>   isNew == false
   * <br/><b>Postcondition:</b>  EnumerationItem is deleted from the database
   * <br/><b>Postcondition:</b>  child relationships are removed
   *        (RelationshipFactory.getChildren(this.getOid(), "")).length == 0
   * <br/><b>Postcondition:</b>  parent relationships are removed
   *        (RelationshipFactory.getParents(this.getOid(), "")).length == 0
   *
   *
   * @param businessContext true if this is being called from a business context, false
   * otherwise. If true then cascading deletes of other Entity objects will happen at the Business
   * layer instead of the data access layer.
   *
   */
  public void delete(boolean businessContext, DeleteContext context)
  {
    super.delete(context);

    List<RelationshipDAOIF> relationships = this.getParents(RelationshipTypes.ENUMERATION_ATTRIBUTE_ITEM.getType());

    for (RelationshipDAOIF relationshipIF : relationships)
    {
      MdEnumerationDAOIF mdEnumerationIF = (MdEnumerationDAOIF)relationshipIF.getParent();
      Database.deleteEumerationItemFromLinkTable(mdEnumerationIF.getTableName(), this.getOid());
    }

    QueryFactory queryFactory = new QueryFactory();
    BusinessDAOQuery mdAttributeQuery = queryFactory.businessDAOQuery(MdAttributeEnumerationInfo.CLASS);
    mdAttributeQuery.WHERE(mdAttributeQuery.aCharacter(MdAttributeEnumerationInfo.DEFAULT_VALUE).EQ(this.getOid()));

    OIterator<BusinessDAOIF> mdAttributeIterator = mdAttributeQuery.getIterator();
    while(mdAttributeIterator.hasNext())
    {
      MdAttributeConcreteDAO mdAttribute = (MdAttributeConcreteDAO)mdAttributeIterator.next();
      mdAttribute.getAttribute(MdAttributeEnumerationInfo.DEFAULT_VALUE).setValue("");
      mdAttribute.save(true);
    }

    mdAttributeQuery = queryFactory.businessDAOQuery(MdAttributeReferenceInfo.CLASS);
    mdAttributeQuery.WHERE(mdAttributeQuery.aCharacter(MdAttributeReferenceInfo.DEFAULT_VALUE).EQ(this.getOid()));

    mdAttributeIterator = mdAttributeQuery.getIterator();
    while(mdAttributeIterator.hasNext())
    {
      MdAttributeConcreteDAO mdAttribute = (MdAttributeConcreteDAO)mdAttributeIterator.next();
      mdAttribute.getAttribute(MdAttributeReferenceInfo.DEFAULT_VALUE).setValue("");
      mdAttribute.save(true);
    }

  }

  /* (non-Javadoc)
   * @see com.runwaysdk.dataaccess.BusinessDAO#getBusinessDAO()
   */
  public EnumerationItemDAO getBusinessDAO()
  {
    return (EnumerationItemDAO) super.getBusinessDAO();
  }


  /**
   * Returns a list of MdEnumerations that include this enumeration option.
   *
   * @return list of MdEnumerations that include this enumeration option.
   */
  public List<MdEnumerationDAOIF> getParticipatingMdEnumerations()
  {
    List<MdEnumerationDAOIF> mdEnumerationIFList = new LinkedList<MdEnumerationDAOIF>();

    List<RelationshipDAOIF> relationshipList = this.getParents(RelationshipTypes.ENUMERATION_ATTRIBUTE_ITEM.getType());
    for (RelationshipDAOIF relationshipIF: relationshipList)
    {
      mdEnumerationIFList.add((MdEnumerationDAOIF)relationshipIF.getParent());
    }

    return mdEnumerationIFList;
  }

  /**
   * Returns a new EnumerationItem with the attributes defined for the class with the given type.
   * Some attributes will contain default values, as defined in the attribute
   * metadata. Otherwise, the attributes will be blank.
   *
   * <br/><b>Precondition:</b> classType parameter represents a valid classType in
   * the database.
   * <br/><b>Precondition:</b> classType must not be abstract,
   * otherwise a DataAccess exception will be thrown
   * <br/><b>Postcondition:</b>
   * EnumerationItem returned is an instance of the given classType. The EnumerationItem
   * contains all attributes defined for that classType.
   *
   * @param classType
   *          Valid type. Examples: Constants.USER, FOLDER
   * @return EnumerationItem instance of the given class
   * @throws com.runwaysdk.dataaccess.DataAccessException
   *           if the class is not valid or is abstract
   */
  public static EnumerationItemDAO newInstance(String classType)
  {
    return (EnumerationItemDAO) BusinessDAO.newInstance(classType);
  }

  /* (non-Javadoc)
   * @see com.runwaysdk.dataaccess.BusinessDAO#get(java.lang.String)
   */
  public static EnumerationItemDAOIF get(String oid)
  {
    return (EnumerationItemDAOIF) BusinessDAO.get(oid);
  }

}
