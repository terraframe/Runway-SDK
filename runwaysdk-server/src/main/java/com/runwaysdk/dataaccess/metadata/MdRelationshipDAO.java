/**
 * Copyright (c) 2015 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Created on Aug 23, 2005
 *
 */
package com.runwaysdk.dataaccess.metadata;

import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import com.runwaysdk.business.generation.GenerationUtil;
import com.runwaysdk.business.generation.GeneratorIF;
import com.runwaysdk.business.generation.RelationshipBaseGenerator;
import com.runwaysdk.business.generation.RelationshipQueryAPIGenerator;
import com.runwaysdk.business.generation.RelationshipStubGenerator;
import com.runwaysdk.business.generation.dto.RelationshipDTOBaseGenerator;
import com.runwaysdk.business.generation.dto.RelationshipDTOStubGenerator;
import com.runwaysdk.business.generation.dto.RelationshipQueryDTOGenerator;
import com.runwaysdk.constants.BusinessInfo;
import com.runwaysdk.constants.ElementInfo;
import com.runwaysdk.constants.EntityCacheMaster;
import com.runwaysdk.constants.EnumerationMasterInfo;
import com.runwaysdk.constants.MdAttributeLocalInfo;
import com.runwaysdk.constants.MdElementInfo;
import com.runwaysdk.constants.MdRelationshipInfo;
import com.runwaysdk.constants.RelationshipTypes;
import com.runwaysdk.constants.VisibilityModifier;
import com.runwaysdk.dataaccess.AttributeEnumerationIF;
import com.runwaysdk.dataaccess.AttributeIF;
import com.runwaysdk.dataaccess.AttributeLocalIF;
import com.runwaysdk.dataaccess.BusinessDAO;
import com.runwaysdk.dataaccess.BusinessDAOIF;
import com.runwaysdk.dataaccess.DataAccessException;
import com.runwaysdk.dataaccess.MdAttributeConcreteDAOIF;
import com.runwaysdk.dataaccess.MdBusinessDAOIF;
import com.runwaysdk.dataaccess.MdElementDAOIF;
import com.runwaysdk.dataaccess.MdRelationshipDAOIF;
import com.runwaysdk.dataaccess.RelationshipDAO;
import com.runwaysdk.dataaccess.RelationshipDAOIF;
import com.runwaysdk.dataaccess.attributes.entity.Attribute;
import com.runwaysdk.dataaccess.attributes.entity.AttributeBoolean;
import com.runwaysdk.dataaccess.attributes.entity.AttributeEnumeration;
import com.runwaysdk.dataaccess.attributes.entity.AttributeReference;
import com.runwaysdk.dataaccess.cache.CacheCodeException;
import com.runwaysdk.dataaccess.cache.ObjectCache;
import com.runwaysdk.dataaccess.database.Database;
import com.runwaysdk.dataaccess.database.EntityDAOFactory;
import com.runwaysdk.dataaccess.database.ServerIDGenerator;
import com.runwaysdk.query.EntityQuery;
import com.runwaysdk.query.OIterator;
import com.runwaysdk.query.QueryFactory;
import com.runwaysdk.query.RelationshipDAOQuery;


/**
 * @author nathan
 *
 */
public class MdRelationshipDAO extends MdElementDAO implements MdRelationshipDAOIF
{

  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = 1541161880193478930L;

  /**
   * The default constructor, does not set any attributes
   */
  public MdRelationshipDAO()
  {
    super();
  }

  /**
   * Returns the signature of the metadata.
   *
   * @return signature of the metadata.
   */
  public String getSignature()
  {
    String signature = super.getSignature();
    signature += " ParentType:"+this.getParentMdBusiness().definesType();
    signature += " ParentTypeVisibility:"+Boolean.toString(this.getParentMdBusiness().isPublished());
    signature += " ParentGetterVisibility:"+this.getParentVisibility().getJavaModifier();
    signature += " ChildType:"+this.getChildMdBusiness().definesType();
    signature += " ChildTypeVisibility:"+Boolean.toString(this.getChildMdBusiness().isPublished());
    signature += " ChildGetterVisibility:"+this.getChildVisibility().getJavaModifier();

    return signature;
  }

  /**
   * Constructs a MdRelationship from the given hashtable of Attributes.
   *
   * <br/><b>Precondition:</b>   attributeMap != null
   * <br/><b>Precondition:</b>   type != null
   *
   * @param attributeMap
   * @param type
   */
  public MdRelationshipDAO(Map<String, Attribute> attributeMap, String type)
  {
    super(attributeMap, type);
  }

  /**
   * Returns true if this is a composition relationship, false otherwise.
   * @return true if this is a composition relationship, false otherwise.
   */
  public boolean isComposition()
  {
    return ((AttributeBoolean)this.getAttributeIF(MdRelationshipInfo.COMPOSITION)).getBooleanValue();
  }

  /**
   *Returns the DataAccessIF object that specifies the cache algorithm used
   * for relationships of this type.
   * @return DataAccessIF object that specifies the cache algorithm used
   *         for relationships of this type.
   */
  public BusinessDAOIF getCacheAlgorithm()
  {
    return ((AttributeEnumeration)this.getAttributeIF(MdRelationshipInfo.CACHE_ALGORITHM)).dereference()[0];
  }

  /**
   *Returns true if instances of this relationship type are cached, false otherwise.
   * @return true if instances of this relationship type are cached, false otherwise.
   */
  public boolean cacheAllInstances()
  {
    BusinessDAOIF cacheEnumItem = this.getCacheAlgorithm();
    int cacheCode = new Integer(cacheEnumItem.getAttributeIF(EntityCacheMaster.CACHE_CODE).getValue()).intValue();

    if (cacheCode == EntityCacheMaster.CACHE_EVERYTHING.getCacheCode())
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  /**
   *Returns the metadata object that defines the type of objects that are parents
   * in this relationship.
   * @return the metadata object that defines the type of objects that are parents
   * in this relationship.
   */
  public MdBusinessDAOIF getParentMdBusiness()
  {
    AttributeReference attributeReference = (AttributeReference)this.getAttributeIF(MdRelationshipInfo.PARENT_MD_BUSINESS);
    return (MdBusinessDAOIF)attributeReference.dereference();
  }

  /**
   *Returns the cardinality of parent instances in this relationship type.  Value is either a
   * positive integer or "*" to represent unlimited instances.
   * @return the cardinality of parent instances in this relationship type.
   */
  public String getParentCardinality()
  {
    return this.getAttributeIF(MdRelationshipInfo.PARENT_CARDINALITY).getValue();
  }

  /**
   *Returns the display label of the role of the parents in this relationship.
   * @return the display label of the role of the parents in this relationship.
   */
  public String getParentDisplayLabel(Locale locale)
  {
    return ((AttributeLocalIF)this.getAttributeIF(MdRelationshipInfo.PARENT_DISPLAY_LABEL)).getValue(locale);
  }

  /**
   * Returns a map where the key is the locale and the value is the localized
   * String value.
   *
   * @return map where the key is the locale and the value is the localized
   *   String value.
   */
  public Map<String, String> getParentDisplayLabes()
  {
    return ((AttributeLocalIF)this.getAttributeIF(MdRelationshipInfo.PARENT_DISPLAY_LABEL)).getLocalValues();
  }

  /**
   * Specifies the name of the getter method for the parent in the relationship.
   * Note that the method actually exists on the child.  For example, in the
   * relationship Person Owns Vehicle (Person is the parent), an appropriate
   * parent_method could be "Owners".  This would result in the method
   * Vehicle.getAllOwners().
   */
  public String getParentMethod()
  {
    return this.getAttributeIF(MdRelationshipInfo.PARENT_METHOD).getValue();
  }

  /**
   * Returns the visibility modifier of the parent method.
   * @return the visibility modifier of the parent method.
   */
  public VisibilityModifier getParentVisibility()
  {
    AttributeEnumerationIF attrEnum = (AttributeEnumerationIF)this.getAttributeIF(MdRelationshipInfo.PARENT_VISIBILITY);

    BusinessDAOIF modifier = attrEnum.dereference()[0];

    String enumName = modifier.getAttributeIF(EnumerationMasterInfo.NAME).getValue();

    return VisibilityModifier.valueOf(enumName);
  }

  /**
   * Specifies the name of the getter method for the child in the relationship.
   * Note that the method actually exists on the parent.  For example, in the
   * relationship Person Owns Vehicle (Vehicle is the child), an appropriate
   * child_method could be "VehiclesOwned".  This would result in the method
   * Person.getAllVehiclesOwned().
   */
  public String getChildMethod()
  {
    return this.getAttributeIF(MdRelationshipInfo.CHILD_METHOD).getValue();
  }

  /**
   *Returns the metadata object that defines the type of objects that are children
   * in this relationship.
   * @return the metadata object that defines the type of objects that are parents
   * in this relationship.
   */
  public MdBusinessDAOIF getChildMdBusiness()
  {
    AttributeReference attributeReference = (AttributeReference)this.getAttributeIF(MdRelationshipInfo.CHILD_MD_BUSINESS);
    return (MdBusinessDAOIF)attributeReference.dereference();
  }

  /**
   *Returns the cardinality of child instances in this relationship type.  Value is either a
   * positive integer or "*" to represent unlimited instances.
   * @return the cardinality of child instances in this relationship type.
   */
  public String getChildCardinality()
  {
    return this.getAttributeIF(MdRelationshipInfo.CHILD_CARDINALITY).getValue();
  }

  /**
   *Returns the display label of the role of the childrend in this relationship.
   *
   *@param locale
   *
   * @return the display label of the role of the childrend in this relationship.
   */
  public String getChildDisplayLabel(Locale locale)
  {
    return ((AttributeLocalIF)this.getAttributeIF(MdRelationshipInfo.CHILD_DISPLAY_LABEL)).getValue(locale);
  }

  /**
   * Returns a map where the key is the locale and the value is the localized
   * String value.
   *
   * @return map where the key is the locale and the value is the localized
   *   String value.
   */
  public Map<String, String> getChildDisplayLabes()
  {
    return ((AttributeLocalIF)this.getAttributeIF(MdRelationshipInfo.CHILD_DISPLAY_LABEL)).getLocalValues();
  }

  /**
   * Returns the visibility modifier of the child method.
   * @return the visibility modifier of the child method.
   */
  public VisibilityModifier getChildVisibility()
  {
    AttributeEnumerationIF attrEnum = (AttributeEnumerationIF)this.getAttributeIF(MdRelationshipInfo.CHILD_VISIBILITY);

    BusinessDAOIF modifier = attrEnum.dereference()[0];

    String enumName = modifier.getAttributeIF(EnumerationMasterInfo.NAME).getValue();

    return VisibilityModifier.valueOf(enumName);
  }

  /**
   * Returns the MdAttribute object that defines the attribute that this relationship should
   * be sorted by default.  If no MdAttribute is referenced, then null is returned.
   * @return MdAttribute object that defines the attribute that this relationship should
   * be sorted by default.  If no MdAttribute is referenced, then null is returned.
   */
  public MdAttributeConcreteDAOIF getSortMdAttribute()
  {
    String sortMdAttributeID = this.getAttributeIF(MdRelationshipInfo.SORT_MD_ATTRIBUTE).getValue();

    if (!sortMdAttributeID.trim().equals(""))
    {
      AttributeReference attributeReference = (AttributeReference)this.getAttributeIF(MdRelationshipInfo.SORT_MD_ATTRIBUTE);
      return (MdAttributeConcreteDAOIF)attributeReference.dereference();
    }
    else
    {
      return null;
    }
  }

  /**
   * Returns an array of MdRelationshipIF that defines immediate subentites of this
   * entity.
   *
   * @return an array of MdRelationshipIF that defines immediate subentites of this
   *         entity.
   */
  public List<MdRelationshipDAOIF> getSubClasses()
  {
    List<RelationshipDAOIF> subRelationshipArray = this
        .getChildren(RelationshipTypes.RELATIONSHIP_INHERITANCE.getType());

    List<MdRelationshipDAOIF> mdRelationshipList = new LinkedList<MdRelationshipDAOIF>();
    for (RelationshipDAOIF relationship : subRelationshipArray)
    {
      mdRelationshipList.add((MdRelationshipDAOIF) relationship.getChild());
    }

    return mdRelationshipList;
  }

  /**
   *Returns a list of MdClassIF objects that represent classes
   * that are subclasses of the given class, including this class,
   * including all recursive entities.
   *
   * @return list of MdClassIF objects that represent classes
   * that are subclasses of the given class, including this class,
   * including all recursive entities.
   */
  @SuppressWarnings("unchecked")
  public List<MdRelationshipDAOIF> getAllSubClasses()
  {
    List<MdRelationshipDAOIF> list = (List<MdRelationshipDAOIF>)super.getAllSubClasses();
    return list;
  }

  /**
   * Returns a list of MdRelationshipIF objects that are subclasses of the given
   * entity. Only non abstract entities are returned (i.e. entities that can be
   * instantiated)
   *
   * @return list of MdRelationshipIF objects that are subclasses of the given entity.
   *         Only non abstract entities are returned (i.e. entities that can be
   *         instantiated)
   */
  @SuppressWarnings("unchecked")
  public List<MdRelationshipDAOIF> getAllConcreteSubClasses()
  {
    List<MdRelationshipDAOIF> list = (List<MdRelationshipDAOIF>)super.getAllConcreteSubClasses();
    return list;
  }

  /**
   * Returns an MdRelationshipIF representing the super entity of this entity, or null if
   * it does not have one.
   *
   * @return an MdRelationshipIF representing the super entity of this entity, or null if
   * it does not have one.
   */
  public MdRelationshipDAOIF getSuperClass()
  {
    if (!this.isRootOfHierarchy())
    {
      String superMdRelationshipId = this.getAttributeIF(MdRelationshipInfo.SUPER_MD_RELATIONSHIP).getValue();
      return MdRelationshipDAO.get(superMdRelationshipId);
    }
    else
    {
      return null;
    }
  }

  /**
   * Returns a list of MdRelationshipIF object representing every parent of this
   * MdRelationshipIF partaking in an inheritance relationship, including this class.
   *
   * @return a list of parent MdRelationshipIF objects
   */
  @SuppressWarnings("unchecked")
  public List<MdRelationshipDAOIF> getSuperClasses()
  {
    List<MdRelationshipDAOIF> list = (List<MdRelationshipDAOIF>)super.getSuperClasses();
    return list;
  }

  /**
   * Returns true if this class is the root class of a hierarchy, false
   * otherwise.
   *
   * @return true if this class is the root class of a hierarchy, false
   *         otherwise.
   */
  public boolean isRootOfHierarchy()
  {
    String superMdEntityId = this.getAttributeIF(MdRelationshipInfo.SUPER_MD_RELATIONSHIP).getValue();
    if (superMdEntityId.trim().equals(""))
    {
      return true;
    }
    else
    {
      return false;
    }
  }

 /**
  * @param businessContext true if this is being called from a business context, false
  * otherwise. If true then cascading deletes of other Entity objects will happen at the Business
  * layer instead of the data access layer.
  *
  */
  // This method is used as a hook for an aspect in TransactionManagement
  public void delete(boolean businessContext, DeleteContext context)
  {
    super.delete(context);
  }

  /**
   *
   *
   */
  protected void validateNew()
  {
    super.validateNew();

    MdRelationshipDAOIF mdRelationshipIF = this.getSuperClass();

    if (mdRelationshipIF != null)
    {
      this.validateParentRelationshipType(mdRelationshipIF);

      MdRelationshipDAOIF superMdRelationshipIF = (MdRelationshipDAOIF)mdRelationshipIF;

      // Only abstract MdRelationships can be extended
      String superRelationship = superMdRelationshipIF.definesType();
      if (!superMdRelationshipIF.isAbstract())
      {
        String error = "[" + definesType() + "] cannot extend [" + superRelationship
            + "] - only abstract relationships can be extended.";
        throw new RelationshipDefinitionException(error);
      }

      MdBusinessDAOIF parentMdBusinessIF = this.getParentMdBusiness();
      MdBusinessDAOIF superParentMdBusinessIF = superMdRelationshipIF.getParentMdBusiness();
      // The class of the parent object for this relationship must be a subclass of the parent object class
      // on the super MdRelationship

      // If the child objects can be of type Component, then instances of any class are allowed.
      if (!superParentMdBusinessIF.definesType().equals(BusinessInfo.CLASS))
      {
        if (!MdElementDAO.isSubEntity(parentMdBusinessIF.definesType(),
                                      superParentMdBusinessIF.definesType()))
        {
          String error = "Relationship [" + definesType() + "] extends [" + superRelationship
              + "]. The parent in a sub-relationship must subclass the parent of "
              + "the super relationship.  In this case, the specified parent type ["
              + parentMdBusinessIF.definesType() + "] does not extend ["
              + superParentMdBusinessIF.definesType() + "] as required.";
          throw new RelationshipDefinitionException(error);
        }
      }

      MdBusinessDAOIF childMdBusinessIF = this.getChildMdBusiness();
      MdBusinessDAOIF superChildMdBusinessIF = superMdRelationshipIF.getChildMdBusiness();
      // The class of the child object for this relationship must be a subclass of the child object class
      // on the super MdRelationship

      // If the child objects can be of type Component, then instances of any class are allowed.
      if (!superChildMdBusinessIF.definesType().equals(BusinessInfo.CLASS))
      {
        if (!MdElementDAO.isSubEntity(childMdBusinessIF.definesType(),
                                       superChildMdBusinessIF.definesType()))
        {
          String error = "Relationship [" + definesType() + "] extends [" + superRelationship
              + "]. The child in a sub-relationship must subclass the child of "
              + "the super relationship.  In this case, the specified child type ["
              + childMdBusinessIF.definesType() + "] does not extend [" + superChildMdBusinessIF.definesType()
              + "] as required.";
          throw new RelationshipDefinitionException(error);
        }
      }
    }
  }

  /**
   * Ensures that the parent relationship type is valid.  An MdRelationship can only extend another
   * MdRelationship.  An MdGraph can only extend another MdGraph.  An MdTree can only extend another
   * MdTree.
   * @param parentMdEntityIF
   */
  protected void validateParentRelationshipType(MdRelationshipDAOIF parentMdRelationshipIF)
  {
    // A MdRelationship can only extend another MdRelationship
    if (!parentMdRelationshipIF.getType().equals(MdRelationshipInfo.CLASS))
    {
      String error = "[" + definesType() + "] cannot extend [" + parentMdRelationshipIF.definesType()
          + "] - it can only extend an [" + this.getType()+"]";
      throw new InheritanceException(error);
    }
  }

  /**
   * Ensure that the method name of the parent and child do not conflict with existing
   * method names for the parent and child
   */
  protected void validateMethodName()
  {
    if (this.isGenerateSource())
    {
      MdBusinessDAOIF child = this.getChildMdBusiness();
      String childMethod = this.getChildMethod();
      String childType = this.getChildMdBusiness().definesType();

      MdBusinessDAOIF parent = this.getParentMdBusiness();
      String parentMethod = this.getParentMethod();
      String parentType = this.getParentMdBusiness().definesType();


      // Do not check for method name conflicts for types we are not generating java classes for.
      if (GenerationUtil.isSkipCompileAndCodeGeneration(child) ||
          GenerationUtil.isSkipCompileAndCodeGeneration(parent))
      {
        return;
      }


      if(checkMethod(childMethod, childType, parent))
      {
        String error = "Class [" + parent.definesType() + "] already contains a method named ["
            + childMethod + "] with type ["+childType+"]. Please specify a different method name and type for the child in [" + definesType()
            + "]";
        throw new RelationshipDefinitionException(error);
      }

      if(checkMethod(parentMethod, parentType, child))
      {
        String error = "Class [" + child.definesType() + "] already contains a method named ["
            + parentMethod + "] with type ["+parentType+"]. Please specify a different method name and type for the parent in ["
            + definesType() + "]";
        throw new RelationshipDefinitionException(error);
      }
    }
  }

  /**
   * Returns if the method name already exists on any relationship for a given mdBusiness.
   *
   * @param method The method name to check
   * @param type type to check
   * @param mdBusinessIF The mdBusiness to check
   * @return
   */
  private boolean checkMethod(String method, String type, MdBusinessDAOIF mdBusinessIF)
  {
    //Check all of MdRelationships which the class is a child
    List<MdRelationshipDAOIF> relationships = mdBusinessIF.getChildMdRelationships();

    for(MdRelationshipDAOIF rel:relationships)
    {
      //Get the name of the child method
      String existingName = rel.getChildMethod();
      String existingType = rel.getParentMdBusiness().definesType();

      if(!this.equals(rel) && method.equals(existingName)
          && existingType.equals(type))
      {
        return true;
      }
    }

    //Check all of MdRelationships which the class is a parent
    relationships = mdBusinessIF.getParentMdRelationships();

    for(MdRelationshipDAOIF rel:relationships)
    {
      //Get the name of the parent method
      String existingName = rel.getParentMethod();
      String existingType = rel.getChildMdBusiness().definesType();

      if(!this.equals(rel) && method.equals(existingName)
          && existingType.equals(type))
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Ensure that sortMdAttribute references an existing MdAttribute of the MdRelationship
   */
  protected void validateSortOrder()
  {
    String sortOrder = getAttribute(MdRelationshipInfo.SORT_MD_ATTRIBUTE).getValue();

    //Do not validate on an empty string
    if(sortOrder.equals(""))
    {
      return;
    }

    //Get a list of attributes that are defined for this relationship
    List<? extends MdAttributeConcreteDAOIF> attributes = this.getAllDefinedMdAttributes();

    boolean valid = false;

    for(MdAttributeConcreteDAOIF attribute:attributes)
    {
      String attributeName = attribute.getOid();

      //Check if the oid of the attribute equals the sort attribute
      if(attributeName.equals(sortOrder))
      {
        valid = true;
      }
    }

    if(!valid)
    {
      String error = "[" + sortOrder + "] is not a valid value for [" + MdRelationshipInfo.SORT_MD_ATTRIBUTE
          + "] on the [" + definesType()
          + "] relationship.  It must reference an existing attribute on the Relationship";
      throw new RelationshipDefinitionException(error);
    }
  }

  /**
   * This method is a hook for TransactionManagement.aj
   */
  public String save(boolean validateRequired)
  {
    if (this.isNew() && !this.isImport() && !this.isAppliedToDB())
    {
      this.getAttribute(MdRelationshipDAOIF.INDEX1_NAME).setValue(generateIndexName());
      this.getAttribute(MdRelationshipDAOIF.INDEX2_NAME).setValue(generateIndexName());
    }

    String oid = super.save(validateRequired);

    return oid;
  }

  /**
   * Generates a name that is unique that can be used for the name of a newly defined index.
   * @return name that is unique that can be used for the name of a newly defined index.
   */
  public static String generateIndexName()
  {
    String autoGenId = ServerIDGenerator.nextID();

    int maxBaseHashLength = Database.MAX_DB_IDENTIFIER_SIZE - 4;

    if (autoGenId.length() < maxBaseHashLength)
    {
      maxBaseHashLength = autoGenId.length();
    }

    autoGenId = autoGenId.replaceAll("-", "");
    autoGenId = autoGenId.substring(0, maxBaseHashLength);

    autoGenId = MdRelationshipDAOIF.INDEX_PREFIX+autoGenId;

    return autoGenId;
  }

  /**
   *Validates this metadata object.
   *
   * @throws DataAccessException when this MetaData object is not valid.
   */
  protected void validate()
  {
    super.validate();

    String component = EntityDAOFactory.getTypeNameFromType(ElementInfo.CLASS);
    MdBusinessDAOIF mdParent = this.getParentMdBusiness();

    String parentType = mdParent.getTypeName();

    //Ensure that the parent MdBusiness is not of type component
    if(parentType.equals(component))
    {
      String error = "Realtionship [" + definesType() + "] cannot specify [" + component
          + "] as the parent type.";
      throw new RelationshipDefinitionException(error);
    }

    MdBusinessDAOIF mdChild = this.getChildMdBusiness();

    String childType = mdChild.getTypeName();

    //Ensure that the parent MdBusiness is not of type component
    if(childType.equals(component))
    {
      String error = "Realtionship [" + definesType() + "] cannot specify [" + component
      + "] as the child type.";
      throw new RelationshipDefinitionException(error);
    }

    // Validate the parent cardinality value
    if (this.getAttributeIF(MdRelationshipInfo.PARENT_CARDINALITY).isModified())
    {
      this.validateCaridnality(this.getAttributeIF(MdRelationshipInfo.PARENT_CARDINALITY));
    }
    // Validate the child cardinality value
    if (this.getAttributeIF(MdRelationshipInfo.CHILD_CARDINALITY).isModified())
    {
      this.validateCaridnality(this.getAttributeIF(MdRelationshipInfo.CHILD_CARDINALITY));
    }

    AttributeIF cacheAlgorithmAttributeIF = this.getAttributeIF(MdRelationshipInfo.CACHE_ALGORITHM);
    if (cacheAlgorithmAttributeIF.isModified())
    {
      // check that the relationship doesn't have an MRU cache
      BusinessDAOIF algorithm = this.getCacheAlgorithm();
      int code = Integer.parseInt(algorithm.getAttributeIF(EntityCacheMaster.CACHE_CODE).getValue());
      if(code == EntityCacheMaster.CACHE_MOST_RECENTLY_USED.getCacheCode())
      {
        String error = "Relationship [" + definesType() + "] cannot cache ["
            + ((AttributeLocalIF)algorithm.getAttributeIF(EntityCacheMaster.DISPLAY_LABEL)).getValue(MdAttributeLocalInfo.DEFAULT_LOCALE) + "].";
        throw new CacheCodeException(error, this, null);
      }

      if (this.isAbstract() && code == EntityCacheMaster.CACHE_EVERYTHING.getCacheCode())
      {
        String error = "Abstract Relationship [" + definesType() + "] cannot cache ["
            + ((AttributeLocalIF)algorithm.getAttributeIF(EntityCacheMaster.DISPLAY_LABEL)).getValue(MdAttributeLocalInfo.DEFAULT_LOCALE)+ "].";
        throw new CacheCodeException(error, this, null);
      }
    }

    validateMethodName();
    validateSortOrder();
  }

  /**
   *
   *
   */
  protected void validateExisting()
  {
    super.validateExisting();

    AttributeIF abstractAttributeIF = this.getAttributeIF(MdElementInfo.ABSTRACT);
    if (abstractAttributeIF.isModified())
    {
      String error = "Relationship [" + definesType() + "] can not modify the ["
          + MdRelationshipInfo.ABSTRACT + "] attribute.";
      throw new RelationshipDefinitionException(error);
    }

  }

  /**
   * Throws an exception of the given attribute does not contain a valid
   * caridnality value.  Valid values include any positive integer or a
   * windlcard "*".
   *
   * <br/><b>Precondition:</b>  mdRelationship != null
   * <br/><b>Precondition:</b>  cardinalityAttribute.getName().equals(MdRelationshipIF.PARENT_CARDINALITY) ||
   *                            cardinalityAttribute.getName().equals(MdRelationshipIF.CHILD_CARDINALITY)
   * <br/><b>Postcondition:</b> true
   *
   * @throws DatabaseAccessException when given cardinality value is not valid.
   * @param cardinalityAttribute attribute object representing either a parent
   *        or child cardinality value for a MdRelationship.
   */
  private void validateCaridnality(AttributeIF cardinalityAttribute)
  {
    // First, make sure that the cardinality value is either a postive number or an *
    boolean isValidInt = true;
    boolean isValidCardinality = true;
    String cardinalityValue = cardinalityAttribute.getValue().trim();
    try
    {
      int cardinalityInt = Integer.parseInt(cardinalityValue);
      if (cardinalityInt < 1)
      {
        isValidInt = false;
        isValidCardinality = false;
      }
    }
    catch (NumberFormatException ex)
    {
      isValidInt = false;
    }

    if (!cardinalityValue.equals("*") && !isValidInt)
    {
      isValidCardinality = false;
    }

    if (!isValidCardinality)
    {
      String error = "Attribute [" + cardinalityAttribute.getName() + "] on relationship ["
          + definesType() + "] must be less than or equal to the value specified in the parent ["
          + getSuperClass().definesType() + "]";
      throw new RelationshipDefinitionException(error);
    }

    List<? extends MdElementDAOIF> childEntityList = this.getSubClasses();
    for (MdElementDAOIF childMdEntityIF : childEntityList)
    {
      MdRelationshipDAOIF childMdRelationshipIF = (MdRelationshipDAOIF)childMdEntityIF;
      AttributeIF childCardinalityAttribute = null;
      if (cardinalityAttribute.getName().equals(MdRelationshipInfo.PARENT_CARDINALITY))
      {
        childCardinalityAttribute = childMdRelationshipIF.getAttributeIF(MdRelationshipInfo.PARENT_CARDINALITY);
      }
      else
      {
        childCardinalityAttribute = childMdRelationshipIF.getAttributeIF(MdRelationshipInfo.CHILD_CARDINALITY);
      }

      //Second,  Check the the cardinality with respect to the child relationship type
      this.validateCardinalityValueWithInheritance(cardinalityAttribute, childCardinalityAttribute);
    }

    // Third, make sure it does not violate the cardinality of the parent.
    MdElementDAOIF superMdEntityIF = this.getSuperClass();

    if (superMdEntityIF == null)
    { // The struct check for this and throw an exception.
      return;
    }

    MdRelationshipDAOIF mdRelationshipIF = (MdRelationshipDAO)superMdEntityIF;

    AttributeIF parentCardinalityAttribute = null;
    if (cardinalityAttribute.getName().equals(MdRelationshipInfo.PARENT_CARDINALITY))
    {
      parentCardinalityAttribute = mdRelationshipIF.getAttributeIF(MdRelationshipInfo.PARENT_CARDINALITY);
    }
    else
    {
      parentCardinalityAttribute = mdRelationshipIF.getAttributeIF(MdRelationshipInfo.CHILD_CARDINALITY);
    }

    // Check the the cardinality with respect to the parent relationship type
    this.validateCardinalityValueWithInheritance(parentCardinalityAttribute, cardinalityAttribute);


  }

  /**
   * Validates the cardinality with respect to inheritance.
   *
   *
   * @param superCardinalityAttribute
   * @param thisCardinalityAttribute
   */
  private void validateCardinalityValueWithInheritance(AttributeIF superCardinalityAttribute, AttributeIF thisCardinalityAttribute)
  {
    String superCardinality = superCardinalityAttribute.getValue().trim();
    String thisCardinality = thisCardinalityAttribute.getValue().trim();

    boolean isValidCardinality = true;
    // Parent cardinality is an integer
    if (!superCardinality.equals("*"))
    {
      // child is specifying a greater cardinality than the parent
      if (thisCardinality.equals("*"))
      {
        isValidCardinality = false;
      }
      // child cardinality is an integer.
      else
      {
        // Assume this is a valid int, as the code at the begining of the calling method would throw an exception
        // if it is not.
        int cardinalityInt = Integer.parseInt(thisCardinality);

        // Assume the parent is a valid int, as an exception would have been thrown when the parent class was created.
        int parentCardinalityInt = Integer.parseInt(superCardinality);

        if (cardinalityInt > parentCardinalityInt)
        {
          isValidCardinality = false;
        }
      }
    }
    // If the parent cardinality is '*', then the child cardinality can be anything

    if (!isValidCardinality)
    {
      // The parent could be null.  Don't throw a NullPointer trying ot build an error message
      String superType = "null";
      MdElementDAOIF superEntity = getSuperClass();
      if (superEntity!=null) superType = superEntity.definesType();

      String error = "Attribute [" + thisCardinalityAttribute.getName() + "] on relationship ["
          + definesType() + "] must be less than or equal to the value specified in the parent ["
          + superType + "]";
      throw new RelationshipDefinitionException(error);
    }
  }


  /**
   * Creates a table for this entity.
   * <br/><b>Precondition</b>: table for this entity does not already exist.
   */
  protected void createEntityTable()
  {
    String tableName = this.getTableName();
    String index1Name = this.getAttributeIF(MdRelationshipDAOIF.INDEX1_NAME).getValue();
    String index2Name = this.getAttributeIF(MdRelationshipDAOIF.INDEX2_NAME).getValue();
    Database.createRelationshipTable(tableName, index1Name, index2Name, false);
  }

  /**
   * Creates indexes on the table.
   */
  protected void createTableIndexes()
  {
    String tableName = this.getTableName();
    String index1Name = this.getAttributeIF(MdRelationshipDAOIF.INDEX1_NAME).getValue();
    String index2Name = this.getAttributeIF(MdRelationshipDAOIF.INDEX2_NAME).getValue();
    Database.createRelationshipTableIndexesBatch(tableName, index1Name, index2Name, false);
  }

  /**
   *
   * @return
   */
  protected boolean createInheritanceRelationship()
  {
    boolean createInheritanceRelationship = false;

    MdRelationshipDAOIF superMdRelationship = this.getSuperClass();
    // Create an inheritance relationship, if one is specified.
    if (superMdRelationship != null)
    {
      if (!superMdRelationship.isExtendable())
      {
        String error = "Super Relationship [" + superMdRelationship.definesType() + "] cannot be extended.";
        throw new RelationshipInvalidParentDefException(error, superMdRelationship);
      }

      createInheritanceRelationship = true;
    }

    return createInheritanceRelationship;
  }

  /**
   * Updates the key on the inheritance relationship.
   * 
   * <br/>
   * <b>Precondition:</b>the key has been modified
   */
  protected void updateInheritanceRelationshipKey()
  {
    List<RelationshipDAOIF> parentInheritances = this.getParents(RelationshipTypes.RELATIONSHIP_INHERITANCE.getType());
    
    for (RelationshipDAOIF parentInheritanceDAOIF : parentInheritances)
    {
      RelationshipDAO parentInheritanceDAO = parentInheritanceDAOIF.getRelationshipDAO();
      parentInheritanceDAO.setKey(this.getKey());
      parentInheritanceDAO.save(true);
    }
  }
  
  /**
   *
   *
   */
  protected void createInheritanceNew()
  {
    // extend the new class with the given super class
    MdRelationshipDAO superMdRelationship = this.getSuperClass().getBusinessDAO();
    superMdRelationship.addSubMdRelationship(this);
  }

  /**
   * Creates the relationship such that this class becomes superclass of the
   * given class.
   *
   * @param mdRelationshipIF
   *          to become a subclass of this class.
   */
  protected void addSubMdRelationship(MdRelationshipDAOIF mdRelationshipIF)
  {
    RelationshipDAO newChildRelDAO = this.addChild(mdRelationshipIF, RelationshipTypes.RELATIONSHIP_INHERITANCE.getType());
    newChildRelDAO.setKey(mdRelationshipIF.getKey());
    newChildRelDAO.save(true);
  }

  /**
   * Deletes all BusinessDAO instances of this type.
   *
   * <br/><b>Postcondition:</b> All instances of this class are deleted.
   *
   * @param businessContext true if this is being called from a business context, false
   * otherwise. If true then cascading deletes of other Entity objects will happen at the Business
   * layer instead of the data access layer.
   *
   */
  public void deleteInstances(DeleteContext context)
  {
    // delete all instances of the relationship
    QueryFactory queryFactory = new QueryFactory();
    RelationshipDAOQuery relationshipQuery = queryFactory.relationshipDAOQuery(this.definesType());
    OIterator<RelationshipDAOIF> relationshiopIterator = relationshipQuery.getIterator();
    while (relationshiopIterator.hasNext())
    {
      RelationshipDAO resultObject = (RelationshipDAO)relationshiopIterator.next();
      resultObject.delete(context);
    }
  }

  /**
   * Deletes the  table for this entity.
   * <br/><b>Precondition</b>: table for this entity must already exist.
   */
  protected void deleteEntityTable()
  {
    String index1Name = this.getAttributeIF(MdRelationshipDAOIF.INDEX1_NAME).getValue();
    String index2Name = this.getAttributeIF(MdRelationshipDAOIF.INDEX2_NAME).getValue();
    Database.dropRelationshipTable(this.getTableName(), index1Name, index2Name, false);
  }


  /* (non-Javadoc)
   * @see com.runwaysdk.dataaccess.BusinessDAO#create(java.util.Hashtable)
   */
  public MdRelationshipDAO create(Map<String, Attribute> attributeMap, String classType)
  {
    return new MdRelationshipDAO(attributeMap, MdRelationshipInfo.CLASS);
  }

  /* (non-Javadoc)
   * @see com.runwaysdk.dataaccess.BusinessDAO#getBusinessDAO()
   */
  public MdRelationshipDAO getBusinessDAO()
  {
    return (MdRelationshipDAO) super.getBusinessDAO();
  }

  /**
   * Returns the MdRelationshipIF that defines the relationship type
   * with the given type.
   *
   * <br/><b>Precondition:</b>   relationshipType != null
   * <br/><b>Precondition:</b>   !relationshipType.trim().equals("")
   * <br/><b>Precondition:</b>   relationshipType is a valid relationship type defined in the database
   * <br/><b>Postcondition:</b>  return value is not null
   *
   * @param relationshipType type of the relationship.
   * @return MdRelationshipIF that defines the relationship with the given type
   * @throws DataAccessException if the relationship type is not valid.
   */
  public static MdRelationshipDAOIF getMdRelationshipDAO(String relationshipType)
  {
    return ObjectCache.getMdRelationshipDAO(relationshipType);
  }

  /**
   * Returns a EntityQuery object for instances of the given type.
   * @return EntityQuery object for instances of the given type.
   */
  public EntityQuery getEntityQuery()
  {
    QueryFactory queryFactory = new QueryFactory();
    return queryFactory.relationshipDAOQuery(this.definesType());
  }

  /**
   * Returns a new MdRelationship.
   * Some attributes will contain default values, as defined in the attribute
   * metadata. Otherwise, the attributes will be blank.
   *
   * @return MdRelationship.
   */
  public static MdRelationshipDAO newInstance()
  {
    return (MdRelationshipDAO) BusinessDAO.newInstance(MdRelationshipInfo.CLASS);
  }

  /* (non-Javadoc)
   * @see com.runwaysdk.dataaccess.BusinessDAO#get(java.lang.String)
   */
  public static MdRelationshipDAOIF get(String oid)
  {
    return (MdRelationshipDAOIF) BusinessDAO.get(oid);
  }

  /**
   * Returns a list of all generators used to generate source
   * for this MdType.
   *
   * @return
   */
  public List<GeneratorIF> getGenerators()
  {
    List<GeneratorIF> list = new LinkedList<GeneratorIF>();

    //Dont generate reserved types
    if (GenerationUtil.isSkipCompileAndCodeGeneration(this))
    {
      return list;
    }

    list.add(new RelationshipBaseGenerator(this));
    list.add(new RelationshipStubGenerator(this));
    list.add(new RelationshipDTOBaseGenerator(this));
    list.add(new RelationshipDTOStubGenerator(this));

    if (!GenerationUtil.isHardcodedType(this))
    {
      list.add(new RelationshipQueryAPIGenerator(this));
      list.add(new RelationshipQueryDTOGenerator(this));
    }

    return list;
  }

  public String toString()
  {
    return '[' + definesType() + " definition]";
  }
}
