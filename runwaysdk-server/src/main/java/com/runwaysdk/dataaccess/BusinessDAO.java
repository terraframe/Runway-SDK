/**
 * Copyright (c) 2015 TerraFrame, Inc. All rights reserved.
 *
 * This file is part of Runway SDK(tm).
 *
 * Runway SDK(tm) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Runway SDK(tm) is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Runway SDK(tm).  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Created on August 13, 2004
 */
package com.runwaysdk.dataaccess;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.runwaysdk.business.Business;
import com.runwaysdk.business.BusinessFacade;
import com.runwaysdk.business.Relationship;
import com.runwaysdk.business.generation.GenerationUtil;
import com.runwaysdk.business.state.InvalidEntryStateException;
import com.runwaysdk.business.state.MdStateMachineDAOIF;
import com.runwaysdk.business.state.StateMasterDAOIF;
import com.runwaysdk.constants.MdRelationshipInfo;
import com.runwaysdk.dataaccess.attributes.AttributeValueException;
import com.runwaysdk.dataaccess.attributes.entity.Attribute;
import com.runwaysdk.dataaccess.cache.DataNotFoundException;
import com.runwaysdk.dataaccess.cache.ObjectCache;
import com.runwaysdk.dataaccess.database.BusinessDAOFactory;
import com.runwaysdk.dataaccess.database.RelationshipDAOFactory;
import com.runwaysdk.dataaccess.metadata.MdBusinessDAO;
import com.runwaysdk.dataaccess.metadata.MdRelationshipDAO;
import com.runwaysdk.query.BusinessDAOQuery;
import com.runwaysdk.query.Condition;
import com.runwaysdk.query.OIterator;
import com.runwaysdk.query.OR;
import com.runwaysdk.query.QueryFactory;

/**
 * A BusinessDAO has a collection of attributes. Each attribute is a name-value
 * pair. The BusinessDAO class is the main abstraction of the dataaccess layer.
 * BusinessDAOs can participate in relationships with other BusinessDAOs. A
 * BusinessDAO's class determines the number and kinds of attributes for this
 * BusinessDAO.
 * 
 * @author nathan
 * @version $Revision: 1.26 $
 * @since 1.4
 */
public class BusinessDAO extends ElementDAO implements BusinessDAOIF
{
  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = 2824646979293186580L;

  /**
   * The default constructor, does not set any attributes
   */
  public BusinessDAO()
  {
    super();
  }

  /**
   * Constructs a BusinessDAO from the given hashtable of Attributes.
   * 
   * <br/>
   * <b>Precondition:</b> attributeMap != null <br/>
   * <b>Precondition:</b> classType != null
   * 
   * @param attributeMap
   * @param classType
   */
  public BusinessDAO(Map<String, Attribute> attributeMap, String classType)
  {
    super(attributeMap, classType);
  }

  /**
   * Creates an empty BusinessDAO. For subclasses creates a subtype based on the
   * classType, and fills the attributes with the attribute map
   * 
   * @param attributeMap
   *          The attribute mappings of the class
   * @return The new class created
   */
  public BusinessDAO create(Map<String, Attribute> attributeMap, String classType)
  {
    return new BusinessDAO(attributeMap, classType);
  }

  /**
   * Returns a deep cloned-copy of this BusinessDAO
   */
  public BusinessDAO getBusinessDAO()
  {
    // Only clone the object if this object comes from a cache.
    if (this.isFromCache())
    {
      return this.clone();
    }
    else
    {
      return this;
    }
  }

  /**
   * Returns an array of Relationship objects that represent child relationships
   * with this BusinessDAO of the given relationship type.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type:
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO for the given relationship type
   * 
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return Array of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getChildren(String relationshipType)
  {
    return ObjectCache.getChildren(this.getId(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent child relationships between the this object and the given
   * child object.
   * 
   * <br/>
   * <b>Precondition:</b> childObject != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO with the given child for the given
   * relationship type
   * 
   * @param childObject
   *          object that is a child of this object.
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects
   */
  public List<RelationshipDAOIF> getChildren(BusinessDAOIF childObject, String relationshipType)
  {
    return this.getChildren(childObject.getId(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent child relationships between the this object and the child
   * object with the given id.
   * 
   * <br/>
   * <b>Precondition:</b> childId != null <br/>
   * <b>Precondition:</b> !childId.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipTypeis a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO with the given child for the given
   * relationship type
   * 
   * @param childId
   *          id to the child of this object.
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects.
   */
  public List<RelationshipDAOIF> getChildren(String childId, String relationshipType)
  {
    return RelationshipDAOFactory.get(this.getId(), childId, relationshipType);
  }

  /**
   * Returns a LinkedList of Relationship objects that represent child
   * relationships with this BusinessDAO for relationships if all names.
   * 
   * <br/>
   * <b>Precondition:</b> true
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of child
   * relationships to this BusinessDAO
   * 
   * @return LinkedList of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getAllChildren()
  {
    List<RelationshipDAOIF> relationshipList = new LinkedList<RelationshipDAOIF>();

    List<MdRelationshipDAOIF> mdRelationshipList = this.getMdBusinessDAO().getAllParentMdRelationships();

    for (MdRelationshipDAOIF mdRelationshipIF : mdRelationshipList)
    {
      if (mdRelationshipIF.isAbstract())
      {
        continue;
      }

      relationshipList.addAll(ObjectCache.getChildren(this.getId(), mdRelationshipIF.definesType()));
    }
    return relationshipList;
  }

  /**
   * Returns an array of Relationship objects that represent parent
   * relationships with this BusinessDAO of the given relationship type.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO for the given relationship type
   * 
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return array of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getParents(String relationshipType)
  {
    return ObjectCache.getParents(this.getId(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent parent relationships between the this object and the given
   * parent object.
   * 
   * <br/>
   * <b>Precondition:</b> parentObject != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO with the given parent for the given
   * relationship type
   * 
   * @param parentObject
   *          object that is a parent of this object.
   * @param relationshipType
   *          Relationship type specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects
   */
  public List<RelationshipDAOIF> getParents(BusinessDAOIF parentObject, String relationshipType)
  {
    return this.getParents(parentObject.getId(), relationshipType);
  }

  /**
   * Returns an array of Relationship objects of the given relationship type
   * that represent parent relationships between the this object and the parent
   * object with the given id.
   * 
   * <br/>
   * <b>Precondition:</b> parentId != null <br/>
   * <b>Precondition:</b> !parentId.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.)
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO with the given parent for the given
   * relationship type
   * 
   * @param parentId
   *          id to a parent of this object.
   * @param relationshipType
   *          relationshipType specifying which relationship objects to be
   *          returned
   * @return List of Relationship objects
   */
  public List<RelationshipDAOIF> getParents(String parentId, String relationshipType)
  {
    return RelationshipDAOFactory.get(parentId, this.getId(), relationshipType);
  }

  /**
   * Returns a LinkedList of Relationship objects that represent parent
   * relationships with this BusinessDAO for relationships of all names.
   * 
   * <br/>
   * <b>Precondition:</b> true
   * 
   * <br/>
   * <b>Postcondition:</b> Returns all Relationship objects of parent
   * relationships to this BusinessDAO
   * 
   * @return LinkedList of Relationship objects and NOT BusinessDAOs
   */
  public List<RelationshipDAOIF> getAllParents()
  {
    List<RelationshipDAOIF> relationshipList = new LinkedList<RelationshipDAOIF>();

    List<MdRelationshipDAOIF> mdRelationshipList = this.getMdBusinessDAO().getAllChildMdRelationships();

    for (MdRelationshipDAOIF mdRelationshipIF : mdRelationshipList)
    {
      if (mdRelationshipIF.isAbstract())
      {
        continue;
      }

      relationshipList.addAll(ObjectCache.getParents(this.getId(), mdRelationshipIF.definesType()));
    }
    return relationshipList;
  }

  /**
   * Add the given BusinessDAO as a child to this BusinessDAO for the given
   * relationship.
   * 
   * <br/>
   * <b>Precondition:</b> childBusinessDAO != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> adds the BusinessDAO as a child of this BusinessDAO
   * for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param childBusinessDAO
   *          BusinessDAO to be added as a child to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addChild(BusinessDAOIF childBusinessDAO, String relationshipType)
  {
    return addChild(childBusinessDAO.getId(), relationshipType);
  }

  /**
   * Add the BusinessDAO with the given id as a child to this BusinessDAO for
   * the given relationship.
   * 
   * <br/>
   * <b>Precondition:</b> childId != null <br/>
   * <b>Precondition:</b> !childId.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * <br/>
   * <b>Postcondition:</b> adds the BusinessDAO with the given id as a child of
   * this BusinessDAO for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param childId
   *          id of the BusinessDAO to be added as a child to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addChild(String childId, String relationshipType)
  {
    RelationshipDAO newChildRelationship = RelationshipDAO.newInstance(this.getId(), childId, relationshipType);
    return newChildRelationship;
  }

  /**
   * Removes the given BusinessDAO from the children of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childBusinessDAO != null <br/>
   * <b>Precondition:</b> childBusinessDAO is already a child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * @param childBusinessDAO
   *          BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllChildren(BusinessDAOIF childBusinessDAO, String relationshipType)
  {
    this.removeAllChildren(childBusinessDAO, relationshipType, false);
  }

  /**
   * Removes the given BusinessDAO from the children of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childBusinessDAO != null <br/>
   * <b>Precondition:</b> childBusinessDAO is already a child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type.
   * 
   * @param childBusinessDAO
   *          BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllChildren(BusinessDAOIF childBusinessDAO, String relationshipType, boolean businessContext)
  {
    this.removeAllChildren(childBusinessDAO.getId(), relationshipType, businessContext);
  }

  /**
   * Removes the given BusinessDAO with the given id from the children of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childId != null <br/>
   * <b>Precondition:</b> childId is a id to a businessDAO that is already a
   * child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param childId
   *          Id of a BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllChildren(String childId, String relationshipType)
  {
    this.removeAllChildren(childId, relationshipType, false);
  }

  /**
   * Removes the given BusinessDAO with the given id from the children of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> childId != null <br/>
   * <b>Precondition:</b> childId is a id to a businessDAO that is already a
   * child of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param childId
   *          Id of a BusinessDAO to be removed as a child of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllChildren(String childId, String relationshipType, boolean businessContext)
  {
    List<RelationshipDAOIF> relationshipDAOlist = RelationshipDAO.get(this.getId(), childId, relationshipType);

    if (relationshipDAOlist.size() == 0)
    {
      String error = "Object does not have child object with id [" + childId + "], in the [" + relationshipType + "] relationship.";
      throw new DataNotFoundException(error, MdRelationshipDAO.getMdRelationshipDAO(relationshipType));
    }

    for (RelationshipDAOIF relationshipIF : relationshipDAOlist)
    {
      if (businessContext && !GenerationUtil.isReservedType(relationshipIF.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(relationshipIF);
        relationship.delete();
      }
      else
      {
        relationshipIF.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br/>
   * <b>Precondition:</b> id to relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationshipId
   *          id to a child relationship.
   */
  public void removeChild(String relationshipId)
  {
    this.removeChild(relationshipId, false);
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br/>
   * <b>Precondition:</b> id to relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationshipId
   *          id to a child relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeChild(String relationshipId, boolean businessContext)
  {
    RelationshipDAOIF relationshipDAOIF = RelationshipDAO.get(relationshipId);
    this.removeChild(relationshipDAOIF, businessContext);
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipIF != null <br/>
   * <b>Precondition:</b> Relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationship
   *          child relationship.
   */
  public void removeChild(RelationshipDAOIF relationshipIF)
  {
    this.removeChild(relationshipIF, false);
  }

  /**
   * Removes the given relationship that represents a child relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipIF != null <br/>
   * <b>Precondition:</b> Relationship object must represent the a child
   * relationship with this object.
   * 
   * @param relationship
   *          child relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeChild(RelationshipDAOIF relationshipIF, boolean businessContext)
  {
    if (!relationshipIF.getParentId().equals(this.getId()))
    {
      String msg = "Relationship with id [" + relationshipIF.getId() + "] " + "does not represent a child relationship with the object with id [" + getId() + "]";
      throw new DataNotFoundException(msg, MdRelationshipDAO.getMdRelationshipDAO(relationshipIF.getType()));
    }

    if (businessContext && !GenerationUtil.isReservedType(relationshipIF.getMdRelationshipDAO()))
    {
      Relationship relationship = BusinessFacade.get(relationshipIF);
      relationship.delete();
    }
    else
    {
      // Delete the relationship
      relationshipIF.getRelationshipDAO().delete();
    }
  }

  /**
   * Add the given BusinessDAO as a parent to this BusinessDAO for the given
   * relationship.
   * 
   * <br/>
   * <b>Precondition:</b> parentBusinessDAO != null <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type. <br/>
   * <b>Postcondition:</b> adds the BusinessDAO as a parent of this BusinessDAO
   * for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param parentBusinessDAO
   *          BusinessDAO to be added as a parent to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addParent(BusinessDAOIF parentBusinessDAO, String relationshipType)
  {
    return addParent(parentBusinessDAO.getId(), relationshipType);
  }

  /**
   * Add the BusinessDAO with the given id as a parent to this BusinessDAO for
   * the given relationship.
   * 
   * <br/>
   * <b>Precondition:</b> parentId != null && !parentId("") <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType.trim().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * <br/>
   * <b>Postcondition:</b> adds the BusinessDAO with the given id as a parent of
   * this BusinessDAO for the given relationship type <br/>
   * <b>Postcondition:</b> returned Relationship object may not be null
   * 
   * @param parentId
   *          id of BusinessDAO to be added as a child to this BusinessDAO
   * @param relationshipType
   *          Relationship type for the added BusinessDAO
   * @return Relationship object representing the newly created relationship
   */
  public RelationshipDAO addParent(String parentId, String relationshipType)
  {
    RelationshipDAO newParentRelationshipDAO = RelationshipDAO.newInstance(parentId, this.getId(), relationshipType);

    return newParentRelationshipDAO;
  }

  /**
   * Removes the given BusinessDAO from the parents of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentBusinessDAO != null <br/>
   * <b>Precondition:</b> parentBusinessDAO is already a parent of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentBusinessDAO
   *          BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllParents(BusinessDAOIF parentBusinessDAO, String relationshipType)
  {
    this.removeAllParents(parentBusinessDAO, relationshipType, false);
  }

  /**
   * Removes the given BusinessDAO from the parents of this BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentBusinessDAO != null <br/>
   * <b>Precondition:</b> parentBusinessDAO is already a parent of this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentBusinessDAO
   *          BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllParents(BusinessDAOIF parentBusinessDAO, String relationshipType, boolean businessContext)
  {
    this.removeAllParents(parentBusinessDAO.getId(), relationshipType, businessContext);
  }

  /**
   * Removes the BusinessDAO with the given id from the parents of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentId != null <br/>
   * <b>Precondition:</b> parentId a id to an object that is already a parent of
   * this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentId
   *          id to the BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   */
  public void removeAllParents(String parentId, String relationshipType)
  {
    this.removeAllParents(parentId, relationshipType, false);
  }

  /**
   * Removes the BusinessDAO with the given id from the parents of this
   * BusinessDAO.
   * 
   * <br/>
   * <b>Precondition:</b> parentId != null <br/>
   * <b>Precondition:</b> parentId a id to an object that is already a parent of
   * this object. <br/>
   * <b>Precondition:</b> relationshipType != null <br/>
   * <b>Precondition:</b> !relationshipType().equals("") <br/>
   * <b>Precondition:</b> relationshipType is a valid relationship type
   * 
   * @param parentId
   *          id to the BusinessDAO to be removed as a parent of this object
   * @param relationshipType
   *          Relationship type for the removed BusinessDAO
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeAllParents(String parentId, String relationshipType, boolean businessContext)
  {
    List<RelationshipDAOIF> relationshipDAOlist = RelationshipDAO.get(parentId, this.getId(), relationshipType);

    if (relationshipDAOlist.size() == 0)
    {
      String error = "Object does not have parent object with id [" + parentId + "] in the [" + relationshipType + "] relationship.";
      throw new DataNotFoundException(error, MdRelationshipDAO.getMdRelationshipDAO(relationshipType));
    }

    // delete all of the relatinoships
    for (RelationshipDAOIF relationshipIF : relationshipDAOlist)
    {
      if (businessContext && !GenerationUtil.isReservedType(relationshipIF.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(relationshipIF);
        relationship.delete();
      }
      else
      {
        relationshipIF.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br>
   * <b>Precondition:</b> id to relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationshipId
   *          id to a parent relationship.
   */
  public void removeParent(String relationshipId)
  {
    this.removeParent(relationshipId, false);
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br/>
   * <b>Precondition:</b> relationshipId != null <br/>
   * <b>Precondition:</b> !relationshipId().equals("") <br>
   * <b>Precondition:</b> id to relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationshipId
   *          id to a parent relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeParent(String relationshipId, boolean businessContext)
  {
    RelationshipDAOIF relationshipDAOIF = RelationshipDAO.get(relationshipId);
    this.removeParent(relationshipDAOIF, businessContext);
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br>
   * <b>Precondition:</b> relationshipIF != null <br>
   * <b>Precondition:</b> Relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationship
   *          parent relationship.
   */
  public void removeParent(RelationshipDAOIF relationshipIF)
  {
    this.removeParent(relationshipIF, false);
  }

  /**
   * Removes the given relationship that represents a parent relationship with
   * this object.
   * 
   * <br>
   * <b>Precondition:</b> relationshipIF != null <br>
   * <b>Precondition:</b> Relationship object must represent the a parent
   * relationship with this object.
   * 
   * @param relationship
   *          parent relationship.
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   */
  public void removeParent(RelationshipDAOIF relationshipIF, boolean businessContext)
  {
    if (!relationshipIF.getChildId().equals(this.getId()))
    {
      String error = "Relationship with id [" + relationshipIF.getId() + "] " + "does not represent a parent relationship with the object with id [" + getId() + "]";
      throw new DataNotFoundException(error, MdRelationshipDAO.getMdRelationshipDAO(relationshipIF.getType()));
    }

    // Delete the relationship
    if (businessContext && !GenerationUtil.isReservedType(relationshipIF.getMdRelationshipDAO()))
    {
      Relationship relationship = BusinessFacade.get(relationshipIF);
      relationship.delete();
    }
    else
    {
      relationshipIF.getRelationshipDAO().delete();
    }
  }

  /**
   *
   */
  public String save(boolean validateRequired)
  {
    return super.save(validateRequired);
  }

  /**
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   * 
   */
  public void delete(boolean businessContext)
  {
    MdBusinessDAOIF mdBusiness = this.getMdBusinessDAO();

    OIterator<BusinessDAOIF> mdAttrRefIerator = MdBusinessDAO.getAllReferenceAttributes(mdBusiness);
    while (mdAttrRefIerator.hasNext())
    {
      MdAttributeReferenceDAOIF mdAttributeReferenceIF = (MdAttributeReferenceDAOIF) mdAttrRefIerator.next();

      try
      {
        // get the defining parent class
        MdClassDAOIF loopMdEntity = (MdClassDAOIF) mdAttributeReferenceIF.definedByClass();

        if (loopMdEntity instanceof MdEntityDAOIF)
        {
          clearAttributeValues((MdEntityDAOIF) loopMdEntity, mdAttributeReferenceIF, this.getId());
        }
      }
      catch (AttributeValueException e)
      {
        MdEntityDAOIF refMdEntityIF = (MdEntityDAOIF) mdAttributeReferenceIF.definedByClass();
        String error = "Cannot delete object [" + this.getKey() + "] - " + "Attribute [" + mdAttributeReferenceIF.definesAttribute() + "] on type [" + refMdEntityIF.definesType() + "] references it and is a required attribute.";
        throw new CannotDeleteReferencedObject(error, this, refMdEntityIF, mdAttributeReferenceIF);
      }
    }

    mdAttrRefIerator.close();

    QueryFactory queryFactory = new QueryFactory();
    // Perform a cascade delete of any child object if this object participates
    // in a composition relationship
    BusinessDAOQuery mdRelationshipQuery = queryFactory.businessDAOQuery(MdRelationshipInfo.CLASS);

    // cycle through all parent classes of this instance and build the query.
    // OR together MdRelationships where the parent class equals a MdBusiness
    // that is in this object's type
    // hierarchy
    List<MdBusinessDAOIF> inheritsFrom = mdBusiness.getSuperClasses();

    Condition[] conditions = new Condition[inheritsFrom.size()];

    for (int i = 0; i < inheritsFrom.size(); i++)
    {
      MdBusinessDAOIF parentMdBusiness = inheritsFrom.get(i);

      conditions[i] = mdRelationshipQuery.aReference(MdRelationshipInfo.PARENT_MD_BUSINESS).EQ(parentMdBusiness.getId());
    }

    mdRelationshipQuery.WHERE(mdRelationshipQuery.aBoolean(MdRelationshipInfo.COMPOSITION).EQ(true).AND(OR.get(conditions)));

    // get the list of all the MdRelationship objects returned
    OIterator<BusinessDAOIF> businessDAOIterator = mdRelationshipQuery.getIterator();
    while (businessDAOIterator.hasNext())
    {
      // get the name of the relationship
      MdRelationshipDAO relationship = (MdRelationshipDAO) businessDAOIterator.next();
      if (relationship.isAbstract())
      {
        continue;
      }

      List<RelationshipDAOIF> children = this.getChildren(relationship.definesType());

      // now delete each child
      for (RelationshipDAOIF rel : children)
      {
        // get each child, then delete it
        BusinessDAOIF child = rel.getChild();

        // Only perform the delete if the object is mastered at this site, or
        // the
        // delete occurs as a result of an import.
        if (EntityDAO.isMasteredHere(child) || this.isImport())
        {
          if (businessContext && !GenerationUtil.isReservedType(child.getMdBusinessDAO()))
          {
            Business business = BusinessFacade.get(child);
            business.delete();
          }
          else
          {
            BusinessDAO childObject = child.getBusinessDAO();
            childObject.delete();
          }
        }
      }
    }

    // Remove all relationships to this object
    this.deleteFromAllParentRelations(businessContext);
    this.deleteAllChildRelations(businessContext);

    super.delete(businessContext);
  }

  /**
   * Deletes all parent relationships.
   * 
   * <br/>
   * <b>Postcondition:</b> parent relationships are removed
   * (RelationshipFactory.getParents(businessDAO.getId(), "")).length == 0
   * 
   */
  private void deleteFromAllParentRelations(boolean businessContext)
  {
    for (RelationshipDAOIF parent : this.getAllParents())
    {
      if (businessContext && !GenerationUtil.isReservedType(parent.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(parent);
        relationship.delete();
      }
      else
      {
        parent.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Deletes all children relationships.
   * 
   * <br/>
   * <b>Postcondition:</b> parent relationships are removed
   * (RelationshipFactory.getChildren(businessDAO.getId(), "")).length == 0
   * 
   */
  private void deleteAllChildRelations(boolean businessContext)
  {
    for (RelationshipDAOIF child : this.getAllChildren())
    {
      if (businessContext && !GenerationUtil.isReservedType(child.getMdRelationshipDAO()))
      {
        Relationship relationship = BusinessFacade.get(child);
        relationship.delete();
      }
      else
      {
        child.getRelationshipDAO().delete();
      }
    }
  }

  /**
   * Returns a MdBusiness that defines this object's classs.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> true
   * 
   * @return a MdBusiness that defines this object's classs.
   */
  public MdBusinessDAOIF getMdBusinessDAO()
  {
    return MdBusinessDAO.getMdBusinessDAO(this.getType());
  }

  /**
   * Returns a clone of the given BusinessDAO instance. The cloned instance can
   * be applied to the database.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> Clone (deep copy) of this BusinessDAO instance is
   * returned.
   * 
   * @return a clone of the given BusinessDAO instance
   */
  public BusinessDAO clone()
  {
    HashMap<String, Attribute> newAttrList = new HashMap<String, Attribute>();

    // clone all of the attributes
//    for (Attribute attrOld : this.getObjectState().getAttributeMap().values())
    // We are bypassing the abstraction and not calling this.getObjectState().getAttributeMap() to prevent a 
    // stack overflow in the case where the {@link DAOStatePostTransaction} is updating the properties of a 
    // reference after a transaction
    for (Attribute attrOld : this.getObjectState().attributeMap.values())
    {
      Attribute attrNew = attrOld.attributeClone();
      newAttrList.put(attrNew.getName(), attrNew);
    }
    BusinessDAO clonedObject = (BusinessDAO) BusinessDAOFactory.factoryMethod(newAttrList, new String(this.componentType), true);

    clonedObject.setIsNew(this.isNew());
    clonedObject.setAppliedToDB(this.isAppliedToDB());
    return clonedObject;
  }

  /**
   * Returns a copy of the given BusinessDAO instance, with a new id and
   * mastered at the current site. The state of the object is new and has not
   * been applied to the database.
   * 
   * @return a copy of the given BusinessDAO instance
   */
  public BusinessDAO copy()
  {
    HashMap<String, Attribute> newAttrMap = new HashMap<String, Attribute>();

    BusinessDAO copiedObject = BusinessDAO.newInstance(this.getType());

    // clone all of the attributes
    for (Attribute attrOld : this.getObjectState().getAttributeMap().values())
    {
      if (! ( attrOld ).getMdAttribute().isSystem())
      {
        Attribute attrNew = attrOld.attributeCopy();
        attrNew.setContainingComponent(copiedObject);
        newAttrMap.put(attrNew.getName(), attrNew);
      }
    }

    // This should overwrite the non-system attributes, such as id and site
    // master
    copiedObject.getObjectState().getAttributeMap().putAll(newAttrMap);

    return copiedObject;
  }

  /**
   * Tests if <em>this</em> BusinessDAO is a child of another BusinessDAO.
   * 
   * @param possibleParent
   *          the parent BusinessDAO to test with.
   * @param relationshipType
   *          the type of the relationship.
   * @return true if the relationship is valid, false otherwise.
   */
  public boolean isChildOf(BusinessDAO possibleParent, String relationshipType)
  {
    List<RelationshipDAOIF> relList = this.getParents(relationshipType);
    for (RelationshipDAOIF rel : relList)
    {
      BusinessDAOIF parent = rel.getParent();
      BusinessDAO businessDAOParent = parent.getBusinessDAO();

      if (businessDAOParent.getId().compareTo(possibleParent.getId()) == 0)
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Tests if <em>this</em> BusinessDAO is a parent of another BusinessDAO.
   * 
   * @param possibleChild
   *          the child BusinessDAO to test with.
   * @param relationshipType
   *          type of the relationship.
   * @return true if the relationship is valid, false otherwise.
   */
  public boolean isParentOf(BusinessDAO possibleChild, String relationshipType)
  {
    List<RelationshipDAOIF> relList = this.getChildren(relationshipType);
    for (RelationshipDAOIF rel : relList)
    {
      BusinessDAOIF child = rel.getChild();
      BusinessDAO businessDAOChild = child.getBusinessDAO();
      if (businessDAOChild.getId().compareTo(possibleChild.getId()) == 0)
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Returns a BusinessDAO of the given id in the database.
   * 
   * <br/>
   * <b>Precondition:</b> id != null <br/>
   * <b>Precondition:</b> !id.trim().equals("") <br/>
   * <b>Postcondition:</b> return value may not be null <br/>
   * <b>Postcondition:</b> BusinessDAO representing the item in the database of
   * the given id is returned
   * 
   * @param id
   *          element id of an item in the database
   * @return BusinessDAO instance of the given id
   */
  public static BusinessDAOIF get(String id)
  {
    return ObjectCache.getBusinessDAO(id);
  }

  /**
   * Returns a BusinessDAO of the given type with the given key in the database.
   * 
   * <br/>
   * <b>Precondition:</b> key != null <br/>
   * <b>Precondition:</b> !key.trim().equals("") <br/>
   * <b>Precondition:</b> type != null <br/>
   * <b>Precondition:</b> !type.trim().equals("") <br/>
   * <b>Postcondition:</b> BusinessDAO representing the item in the database of
   * the given key and type is returned
   * 
   * @param type
   *          fully qualified type of an item in the database
   * @param key
   *          key of an item in the database
   * 
   * @return BusinessDAO instance of the given type and key
   */
  public static BusinessDAOIF get(String type, String key)
  {
    return (BusinessDAOIF) EntityDAO.get(type, key);
  }

  /**
   * Returns a new BusinessDAO with the attributes defined for the class with
   * the given type. Some attributes will contain default values, as defined in
   * the attribute metadata. Otherwise, the attributes will be blank.
   * 
   * <br/>
   * <b>Precondition:</b> classType parameter represents a valid classType in
   * the database. <br/>
   * <b>Precondition:</b> classType must not be abstract, otherwise a DataAccess
   * exception will be thrown <br/>
   * <b>Postcondition:</b> BusinessDAO returned is an instance of the given
   * classType. The BusinessDAO contains all attributes defined for that
   * classType.
   * 
   * @param classType
   *          Valid classType. Examples: Constants.USER, FOLDER
   * @return BusinessDAO instance of the given class
   * @throws com.runwaysdk.dataaccess.DataAccessException
   *           if the class is not valid or is abstract
   */
  public static BusinessDAO newInstance(String classType)
  {
    return BusinessDAOFactory.newInstance(classType);
  }

  @Override
  public String apply()
  {
    String id = super.apply();

    // If this is the first time the businessDAO has been applied
    // then set the current state to the given entry state
    if (this.isNew())
    {
      this.setEntryStatus();
    }

    return id;
  }

  /**
   * Sets the current status of this dataobjet to the entry states for each
   * state machine defined for the defining MdBusiness of this businessDAO.
   * 
   * @param id
   *          The id this businessDAO.
   */
  private void setEntryStatus()
  {
    // Get the defining class
    MdBusinessDAOIF definingMdBusiness = MdBusinessDAO.getMdBusinessDAO(this.getType());

    // If this type has no State Machine, just bail out.
    if (!definingMdBusiness.hasStateMachine())
      return;

    // Get the state machine
    MdStateMachineDAOIF stateMachine = definingMdBusiness.definesMdStateMachine();

    // Get the entry states of the machine
    StateMasterDAOIF entry = stateMachine.getDefaultState();

    // Get the status mdRelationship defined for the entry state
    MdRelationshipDAOIF rel = stateMachine.getMdStatus(entry);

    // Set the current status relationship of this businessDAO
    RelationshipDAO status = RelationshipDAO.newInstance(this.getId(), entry.getId(), rel.definesType());

    status.apply();
  }

  /*
   * (non-Javadoc)
   * 
   * @see com.runwaysdk.dataaccess.BusinessDAOIF#hasState()
   */
  public boolean hasState()
  {
    // Get the defining class
    MdBusinessDAOIF definingClass = this.getMdBusinessDAO();

    // Check if the defining MdBusiness is associated with a state machine
    if (!definingClass.hasStateMachine())
      return false;

    // Get the status mdRelationship defined for the entry state
    MdTreeDAOIF rel = definingClass.definesMdStateMachine().getMdStatus();
    List<RelationshipDAOIF> list = this.getChildren(rel.definesType());
    return ( list.size() != 0 );
  }

  /**
   * Returns the current state of this businessDAO If there is not state machine
   * defined for the datatype, then an expection is thrown.
   * 
   * @return The current state of the businessDAO
   */
  public StateMasterDAOIF currentState()
  {
    // Get the defining class
    MdBusinessDAOIF definingClass = MdBusinessDAO.getMdBusinessDAO(this.getType());

    if (!definingClass.hasStateMachine() || !this.isAppliedToDB())
    {
      return null;
    }
    else
    {
      // Check if the defining MdBusiness is associated with a state machine
      MdStateMachineDAOIF stateMachine = definingClass.definesMdStateMachine();

      // Get the status mdRelationship defined for the entry state
      MdTreeDAOIF rel = stateMachine.getMdStatus();

      // Get the current status relationship of this businessDAO
      List<RelationshipDAOIF> statuses = this.getChildren(rel.definesType());

      // This DAO does not have a current state even though it should
      // Thus retroactively assign it to the default state
      if (statuses.size() == 0)
      {
        StateMasterDAOIF defaultState = stateMachine.getDefaultState();
        this.setState(defaultState);

        return defaultState;
      }
      else if (statuses.size() > 1)
      {
        String msg = "The businessDAO [" + this.getId() + "] has more than one current state";
        throw new ProgrammingErrorException(msg);
      }

      RelationshipDAOIF currentStatus = statuses.get(0);

      return (StateMasterDAOIF) currentStatus.getChild();
    }
  }

  /**
   * @param entryState
   */
  public void setEntryState(StateMasterDAOIF entryState)
  {
    // Get the defining class
    MdBusinessDAOIF definingClass = this.getMdBusinessDAO();

    List<StateMasterDAOIF> states = definingClass.definesMdStateMachine().getEntryState();
    if (states.contains(entryState))
    {
      setState(entryState);
    }
    else
    {
      String entryStateName = entryState.getName();
      String typeWithMachine = entryState.getMdBusinessDAO().definesType();

      String error = "State [" + entryStateName + "] on machine [" + entryState.getMdBusinessDAO().definesType() + "] is not an entry state";
      throw new InvalidEntryStateException(error, entryStateName, typeWithMachine);
    }
  }

  public MdRelationshipDAOIF getCurrentStatus()
  {
    // Get the defining class
    MdBusinessDAOIF definingClass = this.getMdBusinessDAO();

    // Check if the defining MdBusiness is associated with a state machine
    MdStateMachineDAOIF stateMachine = definingClass.definesMdStateMachine();
    return stateMachine.getMdStatus(this.currentState());
  }

  /**
   * Sets the current state of the session to a new state. Throws an exception
   * if the given newState is not a state from this state machine
   * 
   * @param newState
   * @throws DataNotFoundException
   *           If this datatype does not have a state machine.
   */
  private void setState(StateMasterDAOIF newState)
  {
    // Get the defining class
    MdBusinessDAOIF definingClass = MdBusinessDAO.getMdBusinessDAO(this.getType());

    // Check if the defining MdBusiness is associated with a state machine
    MdStateMachineDAOIF stateMachine = definingClass.definesMdStateMachine();

    // Delete the existing relationship
    deleteCurrentState();

    // Get the status mdRelationship defined for the entry state
    MdRelationshipDAOIF rel = stateMachine.getMdStatus(newState);

    // Set the current status relationship of this businessDAO
    RelationshipDAO status = RelationshipDAO.newInstance(this.getId(), newState.getId(), rel.definesType());

    status.apply();
  }

  private void deleteCurrentState()
  {
    // Get the defining class
    MdBusinessDAOIF definingClass = MdBusinessDAO.getMdBusinessDAO(this.getType());

    // Check if the defining MdBusiness is associated with a state machine
    MdStateMachineDAOIF stateMachine = definingClass.definesMdStateMachine();

    // Get the status mdRelationship defined for the entry state
    MdTreeDAOIF rel = stateMachine.getMdStatus();

    // Get the current status relationship of this businessDAO
    List<RelationshipDAOIF> list = this.getChildren(rel.definesType());

    // If a currentState already exists then remove it
    if (list.size() != 0)
    {
      RelationshipDAO currentStatus = list.get(0).getRelationshipDAO();

      currentStatus.delete();
    }
  }

  /**
   * Promotes the current state of the businessDAO according to some transition
   * 
   * @param transitionName
   *          The name of the transition
   */
  public void promote(String transitionName)
  {
    StateMasterDAOIF currentState = this.currentState();

    StateMasterDAOIF nextState = currentState.getNextState(transitionName);

    this.setState(nextState);
  }

  public String toString()
  {
    return '[' + getType() + ']';
  }
}
